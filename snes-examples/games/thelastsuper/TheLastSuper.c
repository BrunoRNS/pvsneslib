/*
			The Last Super
			
	A small SNES game to celebrate the SNES 30th birthday.
	This game is a sequel / expanded version of a game I originally created in a Jam:
	Keeping SNES Alive: https://drludos.itch.io/keeping-snes-alive
	
						by Dr. Ludos (2020)
	
	Get all my other games: 
			http://drludos.itch.io/
	Support my work and get access to betas and prototypes:
			http://www.patreon.com/drludos

	Gameplay music: xracecar - 7049 Bytes of Memories
	Used under a Creative Commons BY-NC-SA license:
	http://battleofthebits.org/arena/Entry/7049+Bytes+of+Memories/25393/
	
	Title screen music: xracecar - ayyy you know the man
	Used under a Creative Commons BY-NC-SA license:
	http://battleofthebits.org/arena/Entry/ayyy+you+know+the+man.xm/23747/
	
*/

//Include SNESSDK and PVSNESlib
#include <snes.h>

//====================================
//=========== VARIABLES ===============
//====================================

//ASSETS

//Music and sound effects (soundbanks are automatically generated by PVSNESLIB)
#include "soundbank.h"
extern char __SOUNDBANK__0;
extern char __SOUNDBANK__1;
extern char __SOUNDBANK__2;

//Sprites and palettes memory addresses on ROM (defined in data.asm)
extern char sprites16GFX, sprites16GFX_end;
extern char sprites32GFX, sprites32GFX_end;
extern char spritesPAL, spritesPAL_end;

//Tiles, maps and palettes memory addresses on ROM (defined in data.asm)
//Background: gameplay
extern char bg_gameplayGFX, bg_gameplayGFX_end;
extern char bg_gameplayPAL, bg_gameplayPAL_end;
extern char bg_gameplayMAP, bg_gameplayMAP_end;

//Background : text messages (game over, well done)
extern char bg_msgGFX, bg_msgGFX_end;
extern char bg_msgPAL, bg_msgPAL_end;
extern char bg_msgMAP, bg_msgMAP_end;

//Title screen
extern char bg_titleGFX, bg_titleGFX_end;
extern char bg_titlePAL, bg_titlePAL_end;
extern char bg_titleMAP, bg_titleMAP_end;

//Splash screen
extern char bg_splashGFX, bg_splashGFX_end;
extern char bg_splashPAL, bg_splashPAL_end;
extern char bg_splashMAP, bg_splashMAP_end;


//load the font to use with PVSNESLib text system
extern char snesfont;

//Variable to detect if we're running PAL (== 1) or NTSC (==0) mode
extern unsigned char snes_50hz;


//GAMEPLAY VARIABLES

//Define the Screen dimentions
enum {SCREEN_TOP = 2, SCREEN_BOTTOM = 223, SCREEN_LEFT = 3, SCREEN_RIGHT = 252};


//Gameplay and backend variables
u8 STATE; //Current program state : 0: title & howto / 1: gameplay / 2: game over / 3: level completed

//Iterators
u8 i, j, k, l; //8 bit iterators
u16 m; //16 bit iterators

//Ticks counter (frame counter + modulo computed each frame to trigger 4 "every X frame" counter, so we can move at speed slower than 60 pixel / seconds - 60fps game baby!)
//Frame counter (resetted every 240 frames (4 seconds), so it can be used for countdown too)
u8 ticks;
//Fast speed : triggered every 2 frames
u8 ticks_fast;
//Mid speed : triggered every 4 frames
u8 ticks_mid;
//Slow speed : triggered every 8 frames
u8 ticks_slow;
//Slower speed : triggered every 16 frames
u8 ticks_slower;

//This one is used for animation (it's a countdown reused by the game over / title state)
u16 ticks_anim;

//This one is to track the current menu position
u8 menu_step;

//Buffer for palette color change commands (as they need to take place during Vblank!)
//it uses two 16 bits values (one for palette adress, one for the new color data)
u16 colorChangeADDR; 
u16 colorChangeDATA;

//State of the Player 1 gamepad
u16 pad0;

//Pressed buttons vars
u8 pressedJUMP; //for P1

//Pausing / unpausing vars
u8 pressedSTART; // for P1 
u8 pressedSELECT; // for P1 
u8 isPaused; //If == 1, then the game is paused
u8 musicPaused; //If == 1, then the music is paused

//Screenshake vars
u8 screenshake; //used to do the screenshake (if > 0, we shake the screen!)

//Score
u16 score; //will count the number of SNES we managed to play with
u16 highscore; //will store the current highscore (survival mode only)
u8 refreshScore; //if = 1 we will udpate score display (used to avoid doing it every frame, as the printf functions are VERY consuming on the CPU time)

//Gameplay
u8 level; //Current level number
u8 foesRemaining; //number of foes remaining to complete the level (current active foes + the ones in stock)
u8 foesStock; //number of foes remaining in stock (to be spawned when a console is completed)
u8 increase; //Speed at which the "game progress" (0-100) increases: 1: every frame / 2: every 2 frames / 3: every 3 frames, etc. 
u8 decrease; //Speed at which the "tv life" (241-0) decreases: 1: every frame / 2: every 2 frames / 3: every 3 frames, etc.

//Ticks to compute whether we need to increase/decrease value only once for all foes (reduce the CPU load a bit by caching the result as all foes use the same value!)
u8 ticks_increase;
u8 ticks_decrease;

//CARTRIDGE
//Player object (struct)
typedef struct {
	u8 x, y; //X and Y Position
	s8 speedX, speedY; //X and Y speed
	u8 anim; //current animation frame	
	u8 sticky; //0-254: id of the console we are plugged into / 255: free floating in the air!
	u8 graviticks; //personnal gravity counter (for accurate and identical jumps)
} Player;

//Player Animation (all anims are stored here, in a single array of all frames for this object).
//32x32 sprites are stored at 0x6000 (as we won't use the 16x16 ones) => their first tile index is 0
const u16 playerAnim[]={384, 388}; //Sprites are 32x32 here, so 4 frames per "row", and jumping a line imply adding 64 to the first index of the line
//WARNING! If the holder for the sprite frame index is an unsigned char, it means that the sprite frame index will be 255 max
//That will fit many cases, but for a game with more sprites animations, like this one now, be careful to use a unsigned int instead to adress a maximum of 32768 tiles!

//Player 1 variable
Player player={};

//TV AND CONSOLES
//Foe object (struct)
typedef struct {
	u8 active; //0: inactive / 1 : active / 2: disabled (active but without console or console going offscreen) / >=3: transition anim (getting a new console in)
	u8 x, y; //X and Y Position
	s8 speedX, speedY; //X and Y speed
	u8 anim; //current tv animation frame
	u8 consoleX; //current console X pos
	u8 consoleY; //current console Y pos
	u8 consoleAnim; //current console animation frame
	u8 life; //life remaining (before exploding)
	u8 progress; //current game progress (before completion)
	u8 circularX; //if != 255, then we use a circular movement (see LUT tables), and this is the current position index in the LUT. WARNING, we always substract 8 from this value to get the actual index (so we can have it loop seamlessly if needed)
	u8 circularXorigin; //the center X coordinate of the circular movement
	u8 circularXradius; //the current radius (or actually the bitshift divisor) applied to the position retrieved from the LUT (usually 0, 1 or 2)
	u8 circularY; //if != 255, then we use a circular movement (see LUT tables), and this is the current position index in the LUT. WARNING, we always substract 8 from this value to get the actual index (so we can have it loop seamlessly if needed)
	u8 circularYorigin; //the center Y coordinate of the circular movement
	u8 circularYradius; //the current radius (or actually the bitshift divisor) applied to the position retrieved from the LUT (usually 0, 1 or 2)
} Foe;

//Foes animations (all anims are stored here, in a single array of all frames for this object (well actually, one the for TV and one for the consoles, as they don't use the same palette).
//32x32 sprites are stored at 0x6000 (as we won't use the 16x16 ones) => their first tile index is 0
const u16 foeAnim[]={128, 132, 136, 140, 192, 196, 200, 204, 256, 260, 264, 268, 320, 324, 328, 332}; //Sprites are 32x32 here, so 4 frames per "row", and jumping a line imply adding 64 to the first index of the line
const u16 consoleAnim[]={448}; //Sprites are 32x32 here, so 4 frames per "row", and jumping a line imply adding 64 to the first index of the line

//Variable to store all the active foes (all the active "Foe" struct are stored in this array)
Foe foes[10]={NULL};
//Foe pointer
Foe *foe;

//Explosion object (struct)
typedef struct {
	u8 active; //if != 0 then the foe is active
	u8 x, y; //position vars
	s8 speedX, speedY; //speedvars vars
	u8 anim; //current animation frame (index in the anim array)
	u8 delay; //delay to wait before triggering the explosion (N.B. Booms are processed every 4 frames only)
} Boom;
//Explosion animations (all anims are stored here, in a single array of all frames for this object).
//32x32 sprites are stored at 0x6000 (as we won't use the 16x16 ones) => their first tile index is 0
const u16 boomAnim[9]={460, 0, 4, 8, 12, 64, 68, 72, 76}; //Sprites are 32x32 here, so 4 frames per "row", and jumping a line imply adding 64 to the first index of the line

//Variable to store all the active explosions (all the active "Boom" struct are stored in this array)
Boom booms[10]={NULL};
//Boom pointer
Boom *boom;


//Functions declarations
void init();
void startGame();
void buildLevel();
void buildLevel2();
void updateLevel();
void spawnBoom(u8 posX, u8 posY, u8 delay);
void updateBoom();
u8 isCollision( u8 x1, u8 y1, u8 w1, u8 h1, u8 x2, u8 y2, u8 w2, u8 h2 );
//Extern functions coming from other .c files
extern void updateTitle();

//These two lookup tables (LUT) defines X/Y positions to make a "circle-based" movement
//This is the X movement (WARNING: the first 8 indexes are actually junk data, so we can use index 8-247 for the actual movement - it lets us easily loop the movement with negative speed up to -8)
static s8 const LUTcircleX[248]={
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	64,
	64,
	64,
	64,
	64,
	63,
	63,
	63,
	63,
	62,
	62,
	61,
	61,
	60,
	60,
	59,
	58,
	58,
	57,
	56,
	55,
	55,
	54,
	53,
	52,
	51,
	50,
	49,
	48,
	46,
	45, 
	44, 
	43, 
	42, 
	40, 
	39, 
	38, 
	36, 
	35, 
	33,
	32,
	31,
	29,
	28,
	26,
	24, 
	23, 
	21, 
	20, 
	18, 
	17, 
	15, 
	13, 
	12, 
	10, 
	8, 
	7, 
	5, 
	3, 
	2, 
	0, 
	-2,
	-3, 
	-5, 
	-7, 
	-8, 
	-10, 
	-12, 
	-13, 
	-15, 
	-17, 
	-18, 
	-20, 
	-21, 
	-23, 
	-24, 
	-26, 
	-28, 
	-29, 
	-31, 
	-32, 
	-33, 
	-35, 
	-36, 
	-38, 
	-39, 
	-40, 
	-42, 
	-43, 
	-44, 
	-45, 
	-46, 
	-48, 
	-49, 
	-50, 
	-51, 
	-52, 
	-53, 
	-54, 
	-55, 
	-55, 
	-56, 
	-57, 
	-58, 
	-58, 
	-59, 
	-60, 
	-60, 
	-61, 
	-61, 
	-62, 
	-62, 
	-63, 
	-63, 
	-63, 
	-63, 
	-64, 
	-64, 
	-64, 
	-64, 
	-64, 
	-64, 
	-64, 
	-64, 
	-64, 
	-63, 
	-63, 
	-63, 
	-63, 
	-62, 
	-62, 
	-61, 
	-61, 
	-60, 
	-60, 
	-59, 
	-58, 
	-58, 
	-57, 
	-56, 
	-55, 
	-55, 
	-54, 
	-53, 
	-52, 
	-51, 
	-50, 
	-49, 
	-48, 
	-46, 
	-45, 
	-44, 
	-43, 
	-42, 
	-40, 
	-39, 
	-38, 
	-36, 
	-35, 
	-33, 
	-32, 
	-31, 
	-29, 
	-28, 
	-26, 
	-24, 
	-23, 
	-21, 
	-20, 
	-18, 
	-17, 
	-15, 
	-13, 
	-12, 
	-10, 
	-8,
	-7,
	-5,
	-3,
	-2,
	0,
	2, 
	3, 
	5, 
	7, 
	8, 
	10,
	12,
	13, 
	15, 
	17, 
	18, 
	20, 
	21, 
	23, 
	24, 
	26, 
	28, 
	29, 
	31, 
	32, 
	33, 
	35, 
	36, 
	38, 
	39, 
	40, 
	42, 
	43, 
	44, 
	45, 
	46, 
	48, 
	49, 
	50, 
	51, 
	52, 
	53, 
	54, 
	55, 
	55, 
	56, 
	57, 
	58, 
	58, 
	59, 
	60, 
	60, 
	61, 
	61, 
	62, 
	62, 
	63, 
	63, 
	63, 
	63,
	64,
	64,
	64,
	64
};

//This is the Y movement (WARNING: the first 8 indexes are actually junk data, so we can use index 8-247 for the actual movement - it lets us easily loop the movement with negative speed up to -8)
static s8 const LUTcircleY[248]={
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	0,
	2,
	3,
	5,
	7,
	8,
	10,
	12,
	13,
	15,
	17,
	18,
	20,
	21,
	23,
	24,
	26,
	28,
	29,
	31,
	32,
	33,
	35,
	36,
	38,
	39,
	40,
	42,
	43,
	44,
	45,
	46,
	48,
	49,
	50,
	51,
	52,
	53,
	54,
	55,
	55,
	56,
	57,
	58,
	58,
	59,
	60,
	60,
	61,
	61,
	62,
	62,
	63,
	63,
	63,
	63,
	64,
	64,
	64,
	64,
	64,
	64,
	64,
	64,
	64,
	63,
	63,
	63,
	63,
	62,
	62,
	61,
	61,
	60,
	60,
	59,
	58,
	58,
	57,
	56,
	55,
	55,
	54,
	53,
	52,
	51,
	50,
	49,
	48,
	46,
	45,
	44,
	43,
	42,
	40,
	39,
	38,
	36,
	35,
	33,
	32,
	31,
	29,
	28,
	26,
	24,
	23,
	21,
	20,
	18,
	17,
	15,
	13,
	12,
	10,
	8,
	7,
	5,
	3,
	2,
	0,
	-2,
	-3,
	-5,
	-7,
	-8,
	-10,
	-12,
	-13,
	-15,
	-17,
	-18,
	-20,
	-21,
	-23,
	-24,
	-26,
	-28,
	-29,
	-31,
	-32,
	-33,
	-35,
	-36,
	-38,
	-39,
	-40,
	-42,
	-43,
	-44,
	-45,
	-46,
	-48,
	-49,
	-50,
	-51,
	-52,
	-53,
	-54,
	-55,
	-55,
	-56,
	-57,
	-58,
	-58,
	-59,
	-60,
	-60,
	-61,
	-61,
	-62,
	-62,
	-63,
	-63,
	-63,
	-63,
	-64,
	-64,
	-64,
	-64,
	-64,
	-64,
	-64,
	-64,
	-64,
	-63,
	-63,
	-63,
	-63,
	-62,
	-62,
	-61,
	-61,
	-60,
	-60,
	-59,
	-58,
	-58,
	-57,
	-56,
	-55,
	-55,
	-54,
	-53,
	-52,
	-51,
	-50,
	-49,
	-48,
	-46,
	-45,
	-44,
	-43,
	-42,
	-40,
	-39,
	-38,
	-36,
	-35,
	-33,
	-32,
	-31,
	-29,
	-28,
	-26,
	-24,
	-23,
	-21,
	-20,
	-18,
	-17,
	-15,
	-13,
	-12,
	-10,
	-8,
	-7,
	-5,
	-3,
	-2
};

//========================================
//============ PROGRAM INIT ===============
//========================================

//This function is executed only once when the programs boots up, before entering the endless "main loop"
void init() {
	
	//Initialize sound engine (takes some time)
	spcBoot();
	
	//Initialize SNES 
	consoleInit();
	
	//Shut down screen so it doesn't "blink" when loading stuffs (we'll fade in later, the console init automatically set brightness to 15)
	//Thanks to PVSNESlib, setting the Brightness to 0 also puts the console in "forced blank" state, meaning we can upload as many data as we want to the VRAM through DMA without being limited by the VBLank bandwith (~5-6ko each frame)
	setBrightness(0);
	
	//Set the soundbank(s) that we will use. The soundbanks MUST BE DECLARED IN REVERSE ORDER! 
	//I don't know the technical reason why, but I did lost almost 1 hour on this issue before finding the solution here: https://github.com/alekmaul/pvsneslib/issues/11 - Thanks again Alekmaul! ;)
	spcSetBank(&__SOUNDBANK__2);
	spcSetBank(&__SOUNDBANK__1);
	spcSetBank(&__SOUNDBANK__0);
	
	//Allocate around 10K of sound ram (39 256-byte blocks)
	spcAllocateSoundRegion(39);

	//Preload music (load the largest music file so the loaded Sound Effects will be uploaded to sound processor memory after them)
	spcLoad(MOD_MUSIC_TITLE);
	
	//Load all the Sound Effets (they don't use streaming, but the preloaded SFX functions of the snesmod driver : you have 2 SFX playback channels, and no 50/60hz playback issue. But all sounds must fit inside the SPC RAM alongside the music track!)
	//They are loaded AFTER the (largest in the whole game) song module, so they aren't overwritten when changing music
	//FUN FACT: you have to load the SFX in the SAME ORDER of their definition in "soundbank.h", because that's how the driver organize them (you can skip one of course, but don't change order or sounds effects will be swapped or non-working!)
	WaitForVBlank(); //Doing a voluntary vBlank here so we don't overload the SPC with too much loading commands at once
	spcLoadEffect(MOD_AUDIO_CRASH);
	WaitForVBlank();
	spcLoadEffect(MOD_AUDIO_EXPLOSION);
	WaitForVBlank();
	spcLoadEffect(MOD_AUDIO_HIGHSCORE);
	WaitForVBlank();
	spcLoadEffect(MOD_AUDIO_JUMP);
	WaitForVBlank();
	spcLoadEffect(MOD_AUDIO_LIFEUP);
	
	//Do a VBlank now that sound initialisation is finished
	WaitForVBlank();
	
	//Initialize PVSNESlib text system with our font (about 3KB of data, but this function automatically execute a Vblank after and before the DMA transfer it needs)
	//The text will be draw on BG3 (2bpp tiles, so in the Makefile they are converted with a 4 color palette output, and not a 16 color one (else garbage will show up instead)
	//We use Palette 0, because the palette index calculation is different between 4 colors and 16 colours BG, and the Console Text code is based on 16 colors (so if we use palette 0, it works in both mode, for higher palette indexes, it'll only work with 16 colors BGs)
	consoleInitText(2, 0, &snesfont);
	
	//Shut down screen so it doesn't "blink" when loading stuffs and to put the console in "forced blank" mode for easier access to VRAM
	setBrightness(0);	
	
	//Now Put in 16 color mode - Use the BG3_MODE1_PRORITY_HIGH flag to set the BG3 in High priority mode, so it'll be displayed above everyhing (quite useful for a HUD!)
	setMode(BG_MODE1, BG3_MODE1_PRORITY_HIGH); 
	//Scroll the text engine layer (BG3) 2 pixels down so the text isn't touching bottom or top of screen (although we obviously "loose" one screen row by doing so)
	bgSetScroll(2, 0, -2);
	//Hide the BG with text message (game over, well done) at start
	bgSetDisable(0);

	//Load the splash screen Tileset and its palette (on slot 1 and after, as palette slot 0 is for text)
	bgInitTileSet(1, &bg_splashGFX, &bg_splashPAL, 1, (&bg_splashGFX_end - &bg_splashGFX), 16 << 1, BG_16COLORS, 0x2000);
	bgInitMapSet(1, &bg_splashMAP, (&bg_splashMAP_end - &bg_splashMAP), SC_32x32, 0x1000);
	
	//Init Sprites gfx and palette with default size of 16x16 (obj_small) and 32x32 (obj_large)
	//All the sprites and palettes are stored one after another in the ROM.
	//So, instead of loading only one sprite / palette with this init function, we actually load them all at once.
	//oamInitGfxSet inits the oam system, and then load the sprite graphics and palette data straight to VRAM using the memory adresses passed as parameters
	//So we can actually load as many sprites and palette data as we want, i.e. loading several frames and palettes in one pass
	//WARNING! However there is one caveat with this "load several BMP at once" technique:
	//The tool used by PVSNESLib to convert BMP to SNES graphics format will convert each BMP to a multiple of 1024 bit (1Kb)
	//So, for a 16x16 sprite size, it means that, even if the BMP only contains 2 sprites, the convert tool will generate data like if the BMP contains 8 spritse of 16x16 size
	//So, when loading 2 Bmp or more, you are creating "empty space" in OAM if those BMP aren't filled with a number of sprite that is a multiple of 8 (16 for 8x8 sprites, 8 for 16x16 sprites, 4 for 32x32 ones, or 2 for 64x64 sprites)
	//And also, it means that OAM offset of a sprite data for the first image of a BMP will be at the beginning of a "row" in the OAM (i.e. 0-15, 32-47, etc.)
	oamInitGfxSet(&sprites16GFX, (&sprites16GFX_end-&sprites16GFX), &spritesPAL, (&spritesPAL_end-&spritesPAL), 0, 0x6000, OBJ_SIZE16);
	//If the console is not in a "forced blank" (i.e. screen display is off so we have unrestricted acces to VRAM), like we are doing here for program initialisation,
	//be careful of the limited amount of VRAM data you can transfer (no more than ~5-6ko each frame on a NTSC model)
	
	//Load the 32x32 sprites data (obj_large), starting at index 0x6000 because the will actually only use 32x32 sprites! (so yes, we override the data from the 16x16 sprites in VRAM)
	//As we can only have up to 0...511 value in tile offset for each sprite, we can only adress up to 2k of Sprites Tiles (SNES is meant to use dynamically loading sprite tiles to RAM, unlike the NES)
	//So the sprite char data will be stored at values 0x6000-0x7FFF, at the end of VRAM, so the rest is free for the BGs
	//With a 32x32 size, we have a grand total of... 32 different characters (8 rows of 4 colums) - huge sprites does eat up a lot of video memory!
	//The foes char data will stay permantly in VRAM (easier to manage, especially for the foes) - if I did ran out of space (but I didn't), I would simply have used dynamic char loading to VRAM for the player animations
	dmaCopyVram(&sprites32GFX, 0x6000, (&sprites32GFX_end-&sprites32GFX));
	
	//Init the one time only variables
	highscore=0;
	level=0;
	musicPaused=0;
	
	//-= SPLASH SCREEN =-
	
	//Fade in to start the program (because the BG data were set in the previous "init" section, see code above)
	setFadeEffect(FADE_IN);
	
	//Wait for 2 seconds (dirty coding FTW!)
	for( i = 0 ; i < 120 ; ++i ){
		WaitForVBlank();
	}
	
	//Fade out to start the program
	setFadeEffect(FADE_OUT);
	
	//Shut down screen so it doesn't "blink" when loading stuffs and to put the console in "forced blank" mode for easier access to VRAM
	setBrightness(0);	
	
	//Wait for 1/2 seconds (dirty coding FTW!)
	for( i = 0 ; i < 30 ; ++i ){
		WaitForVBlank();
	}
	
	//-= TITLE SCREEN =-
	
	//Load the title screen Tileset and its palette (on slot 1 and after, as palette slot 0 is for text)
	bgInitTileSet(1, &bg_titleGFX, &bg_titlePAL, 1, (&bg_titleGFX_end - &bg_titleGFX), 16 << 1, BG_16COLORS, 0x2000);
	bgInitMapSet(1, &bg_titleMAP, (&bg_titleMAP_end - &bg_titleMAP), SC_32x64, 0x1000);
	
	//Set the state to title screen
	STATE=0;
	
	//Init the title screen variables
	ticks_anim=560;
	ticks=0;
	pressedJUMP=10; //Not 1 because of the "progressive jump" feature, that can increase this variable up to 7
	menu_step=0;
	
	//Reset the color change buffer variables
	colorChangeADDR=0;
	colorChangeDATA=0;
	
	//Change the title screen logo color to black so it can appear fading in red during the intro anim
	//Write the adress of the color to change to the dedicated register (palette1 - color 2)
	REG_CGADD = 0x12; 
	//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
	*CGRAM_PALETTE = RGB5(0, 0, 0) & 0xFF; 
	*CGRAM_PALETTE = RGB5(0, 0, 0) >> 8;
	
	//Change the "intro screen text" colors (3 colors: 5-6-7) to black so they can appear fading in red during the intro anim
	//Write the adress of the color to change to the dedicated register (palette1 - color 5)
	REG_CGADD = 0x15; 
	//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
	*CGRAM_PALETTE = RGB5(0, 0, 0) & 0xFF; 
	*CGRAM_PALETTE = RGB5(0, 0, 0) >> 8;
	//Write the adress of the color to change to the dedicated register (palette1 - color 6)
	REG_CGADD = 0x16; 
	//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
	*CGRAM_PALETTE = RGB5(0, 0, 0) & 0xFF; 
	*CGRAM_PALETTE = RGB5(0, 0, 0) >> 8;
	//Write the adress of the color to change to the dedicated register (palette1 - color 7)
	REG_CGADD = 0x17; 
	//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
	*CGRAM_PALETTE = RGB5(0, 0, 0) & 0xFF; 
	*CGRAM_PALETTE = RGB5(0, 0, 0) >> 8;
	
	//Fade in to start the program
	setFadeEffect(FADE_IN);
}



//====================================
//=========== GAME START ==============
//====================================

//This function (re)inits the game to start playing!
void startGame(){
	
	//The screen is already set to off / forced blanking during this function
	
	//Hide the BG with Game Over / Well Done messages
	bgSetDisable(0);
	//And reset it's scroll back to "Game Over"
	bgSetScroll(0, 0, 0);
	
	//Reset the TV gameplay BG color to its starting value
	//Write the adress of the color to change to the dedicated register (palette 8 - color 16)
	REG_CGADD = 0x9F; 
	//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
	*CGRAM_PALETTE = RGB5(9, 9, 9) & 0xFF; 
	*CGRAM_PALETTE = RGB5(9, 9, 9) >> 8;
	
	//Clear the color change buffer
	colorChangeADDR=0;
	colorChangeDATA=0;

	//Clear the BG3 to erase all text display
	//Fill the text map variable with 0x00 (empty) tile
	for (m=0; m < 0x800; ++m){
		pvsneslibfont_map[m] = 0x00;
	}
	//And send the map to VRAM into the location used by PVSNESlib's text engine (read console.h for more info)
	dmaCopyVram(pvsneslibfont_map, 0x800, 0x800);
	
	//Change the text color
	//Write the adress of the color to change to the dedicated register (palette0 - color 1)
	REG_CGADD = 0x01; 
	//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
	*CGRAM_PALETTE = RGB5(28, 0, 0) & 0xFF; 
	*CGRAM_PALETTE = RGB5(28, 0, 0) >> 8;
	
	//Set state as gameplay
	STATE=1;
	
	//ResetVars
	isPaused=0;
	screenshake=0;
	pressedSTART=1;
	pressedSELECT=1;
	pressedJUMP=10; //Not 1 because of the "progressive jump" feature, that can increase this variable up to 7
	ticks_anim=0;
	foesRemaining=0;
	foesStock=0;
	increase=1;
	decrease=1;
	
	//Reset score
	score=0;
	refreshScore=0;

	//Init player
	player.x=0;
	player.y=224;
	player.speedX=0;
	player.speedY=0;
	player.anim=0;
	player.sticky=0;
	player.graviticks=0;
		
	//Init foes
	for( i = 0 ; i < 10 ; ++i ){
		//Get current foe
		foe=&foes[i];
		//And reset all its vars
		foe->active=0;
		foe->x=0;
		foe->y=224;
		foe->speedX=0;
		foe->speedY=0;
		foe->anim=0;
		foe->life=0;
		foe->progress=0;
		foe->circularX=255;
		foe->circularXorigin=0;
		foe->circularXradius=0;
		foe->circularY=255;
		foe->circularYorigin=0;
		foe->circularYradius=0;
		//Reset it's TV sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSet( (30+i)*4, foe->x, foe->y, 2, 0, 0,  foeAnim[foe->anim], 1);
		oamSetEx((30+i)*4, OBJ_LARGE, OBJ_SHOW);
		oamSetVisible((30+i)*4, OBJ_SHOW);
		//Reset the console related vars
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y; 
		foe->consoleAnim=0;
		//Reset it's Console sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSet( (40+i)*4, foe->consoleX, foe->consoleY, 2, 0, 0,  consoleAnim[foe->consoleAnim], 3);
		oamSetEx((40+i)*4, OBJ_LARGE, OBJ_SHOW);
		oamSetVisible((40+i)*4, OBJ_SHOW);
	}
	
	//Init booms
	for( i = 0 ; i < 10 ; ++i ){
		//Get current boom
		boom=&booms[i];
		//And reset all its vars
		boom->active=0;
		boom->x=0;
		boom->y=224;
		boom->speedX=0;
		boom->speedY=0;
		boom->anim=0;
		boom->delay=0;
		//Reset its sprites too (sprites #5-15 (*4 for the actual id in OAM))
		oamSet( (5+i)*4, boom->x, boom->y, 2, 0, 0,  boomAnim[boom->anim], 0);
		oamSetEx((5+i)*4, OBJ_LARGE, OBJ_SHOW);
		oamSetVisible((5+i)*4, OBJ_SHOW);
	}
	
	//Set the current level layout
	buildLevel();
	
	//Do this after the "build level" as this function may modify the player variables (x, y, etc.) - so doing it now make sure that the sprite will be up to date for the fade in
	//Set Player Sprite parameters - sprite #20 (*4 for the actual id in OAM)
	//Params: id,  xspr, yspr, priority, hflip, vflip, gfxoffset, paletteoffset
	oamSet(80, player.x, player.y, 2, 0, 0, playerAnim[player.anim], 2);
	oamSetEx(80, OBJ_LARGE, OBJ_SHOW);
	oamSetVisible(80, OBJ_SHOW);
	
	//If we are not in survival mode 
	if( level != 200 ){
		
		//Display current goal to reach
		if( foesRemaining < 10 ){
			consoleDrawText(11,0,"GOAL:0%d/0%d", score, (u16)foesRemaining);
		} else {
			consoleDrawText(11,0,"GOAL:0%d/%d", score, (u16)foesRemaining);
		}
		
		//Display current level number
		if( level < 10 ){
			consoleDrawText(29,0,"#0%d", (u16)level);
		} else {
			consoleDrawText(29,0,"#%d", (u16)level);
		}
	}
	//Else, we are  in survival mode
	else {
		//Display current score only (and not a "goal" like in the regular levels)
		if( foesRemaining < 10 ){
			consoleDrawText(12,0,"SCORE:0%d", score);
		} else {
			consoleDrawText(12,0,"SCORE:0%d", score);
		}
	}
	
	//Fade in to start game
	setFadeEffect(FADE_IN);
	
	//Load the default music (in case it was changed)
	spcLoad(MOD_MUSIC_GAME);
	
	//Set the music volume to normal unless the music is "paused", else sets it to mute (we do need to play it because else the player won't be able to "unsilence" it during gameplay if he changes his mind)
	if( musicPaused == 0 ){
		spcSetModuleVolume(100);
	} else {
		spcSetModuleVolume(0);
	}
	//Play Music from the beginning
	spcPlay(0);
};




//====================================
//=========== MAIN LOOP ===============
//====================================
int main(void) {
	
	//Call the Startup Function
	init();
	
	//Infinite main loop
	while(1) {
		
		//Refresh pad values in VBL and Get current pads
		pad0 = padsCurrent(0);
		
		//Modify a palette color if the color buffer was actived in the previous frame (color change, like all VRAM operations, needs to take place during VBlank, and here we are a the beginning of the VBLANK time)
		if( colorChangeADDR != 0 ){
			
			//Write the adress of the color to change to the dedicated register
			REG_CGADD = colorChangeADDR; 
			//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
			*CGRAM_PALETTE = colorChangeDATA & 0xFF; 
			*CGRAM_PALETTE = colorChangeDATA >> 8;
			
			//Clear the color change buffer
			colorChangeADDR=0;
			colorChangeDATA=0;
		}
		
		//=============================
		//======= GAMEPLAY STATE ======
		//=============================
		if( STATE == 1 ){
			
			//If the game isn't Paused
			if( isPaused == 0 ){
			
				//==== FRAME & TICKS COUNTER ====
			
				//Increase the frame counter
				++ticks;
				
				//Reset it to zero every 4 seconds (unsigned char > 255 max, so 240 ticks => 4 seconds is ok)
				if (ticks == 241){
					ticks=1;
				}
				
				//Update the "animation triggers" for everyone
				ticks_fast=!(ticks & 1);
				ticks_mid=!(ticks & 3);
				ticks_slow=!(ticks & 7);
				ticks_slower=!(ticks & 0xF);
				
				//Increase the "player gravity" ticks counter too (separate from other ticks counters so we can reset it at the beginning of each jump without breaking the game)
				++player.graviticks;
				//Reset it to zero every 4 seconds (unsigned char > 255 max, so 240 ticks => 4 seconds is ok)
				if (player.graviticks == 241){
					player.graviticks=1;
				}
				
				//Update the gameplay triggers too (for shutdown countdown / game complete progress)
				ticks_increase=!(ticks % increase);
				//the decrease value countdown is slowed down if the cart is in the air
				if( player.sticky == 255 ){
					ticks_decrease=!(ticks % (decrease+5));
				}
				//Else, normal countdown because we're plugged onto a console
				else {
					ticks_decrease=!(ticks % decrease);
				}
			

				//=========== FOES ===============
				
				//Foe each foe
				for( i = 0 ; i < 10 ; ++i ){
					
					//Get current foe
					foe=&foes[i];
					
					//If the foe is active
					if( foe->active != 0 ){
						
						//Are we still alive?
						if( foe->life > 0 ){
						
							//Update TV part
							
							//Update the foe positions
							
							//X position
							//Normal mode
							if( foe->circularX == 255 ){
								//Move the foe by its current speed
								foe->x += foe->speedX;
							}
							//Circular mode
							else {
								//Increase the current LUT index by the foe speed
								foe->circularX += foe->speedX;
								//Make it loop around the LUT if needed (the first 8 indexes of the LUT are junk data to allow for looping even with negative speed up to -8)
								if( foe->circularX >= 248 ){
									foe->circularX -= 240;
								}
								if( foe->circularX < 8 ){
									foe->circularX += 240;
								}
								//And apply the current position from the LUT containing precomputed circular positions
								//If we have to divide (or actually bitshift) the radius, do it now
								if( foe->circularXradius != 0 ){
									foe->x = foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
								}
								//Else, use the LUT position without dividing it
								else {
									foe->x = foe->circularXorigin+LUTcircleX[foe->circularX];
								}
							}
							
							//Y position
							//Normal mode
							if( foe->circularY == 255 ){
								//Move the foe by its current speed
								foe->y += foe->speedY;
							}
							//Circular mode
							else {
								//Increase the current LUT index by the foe speed
								foe->circularY += foe->speedY;
								//Make it loop around the LUT if needed (the first 8 indexes of the LUT are junk data to allow for looping even with negative speed up to -8)
								if( foe->circularY >= 248 ){
									foe->circularY -= 240;
								}
								if( foe->circularY < 8 ){
									foe->circularY += 240;
								}
								//And apply the current position from the LUT containing precomputed circular positions
								//If we have to divide (or actually bitshift) the radius, do it now
								if( foe->circularYradius != 0 ){
									foe->y = foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
								}
								//Else, use the LUT position without dividing it
								else {
									foe->y = foe->circularYorigin+LUTcircleY[foe->circularY];
								}
							}

							
							//If the foes goes out in X
							if( foe->x < SCREEN_LEFT ){
								foe->x=SCREEN_LEFT;
								foe->speedX=-foe->speedX;
							}
							else if( foe->x > SCREEN_RIGHT-32 ){
								foe->x=SCREEN_RIGHT-32;
								foe->speedX=-foe->speedX;
							}
						
							//If the foes goes out in Y
							if( foe->y < SCREEN_TOP){
								foe->y=SCREEN_TOP;
								foe->speedY=-foe->speedY;
							}
							else if( foe->y > SCREEN_BOTTOM-64 ){
								foe->y=SCREEN_BOTTOM-64;
								foe->speedY=-foe->speedY;
							}
							
							//Life and Progress
							//If the cart is plugged in us
							if( player.sticky == i ){
								
								//Reset it's life to full
								foe->life=241;
								
								//Slowly increase gameplay progress
								if( foe->progress < 100 && ticks_increase){
									++foe->progress;
								}
								
								//Did we complete the game yet?
								if( foe->progress == 100 ){
									
									//Increase score
									++score;
									//And asks it to be refreshed onscreen
									refreshScore=1;
									
									//Decrease the number of consoles remaining to clear to complete the level! (except for survival mode)
									if( foesRemaining > 0 && level != 200 ){
										--foesRemaining;
									}
									
									//Artificially increase the foe progress below the thresold to avoid counting this foe completion twice!
									foe->progress=110;
									
									//Play Sound (unless we finished the level, because we'll play a different sound in the "level ending" code)
									if( foesRemaining != 0 ){
										spcEffect(8, MOD_AUDIO_HIGHSCORE, 248);
									}
									
									//Call the function that manages the level difficulty increase
									updateLevel();
								}
								
								//Update anim according to our current progress state
								if( foe->progress < 99 ){
									//Make the screen loop between 3 still images from the game
									if( ticks_slow ){
										//Increase current animation frame
										++foe->anim;
										//Make it loop if needed
										if( foe->anim > 15 ){
											foe->anim=13;
										}
									}
								}
								else {
									//Display the "The END" still image
									foe->anim=12;
								}
								
								//Update the palette BG color according to our current progress (from black to white)
								//Use the buffer for that, as modifying color palette, like all VRAM operations, needs to take place during VBLANK
								colorChangeADDR=0x9F;
								j=9+(foe->progress / 5);
								colorChangeDATA=RGB5(j, j, j);
								
							}
							//Else, the cart isn't plugged in us
							else {
								
								//Did we finish the current game or are we in console transition anim mode?
								if( foe->progress >= 100 || foe->active > 1 ){
									
									//The current console is done, it's time for a new one!
									
									//Update CONSOLE Part
									//First, make the old console fall out
									if( foe->progress >= 100 ){
										
										//Set the foe in "disabled / console going offscreen" mode
										foe->active = 2;
							
										//Update the console positions
										//Don't update X position as we are falling from previous position!
										//Update Y position solely from our current position
										if( foe->consoleY < 224 ){
											foe->consoleY+=5;
											//Don't go over the limit after a move!
											if( foe->consoleY > 224 ){
												foe->consoleY=224;
											}
										}
										//Else, we reached the out of screen
										else {
											
											//Stop the console dropping anim - the foe will be in "idle / disabled" state (foe.active == 2), unless we gave it a new console
											foe->progress=0;
											
											//And put the console in the offscreen area so we can't see it
											foe->consoleY=224;

											//If the stock is not empty
											if( foesStock > 0 ){
												//Decrease the number of console remaining in stock (except for survival mode)
												if( level != 200 ){
													--foesStock;
												}
												
												//Set the foe in "new console incoming!" mode (i.e. trigger the transition anim)
												foe->active = 61;
											}
										}
									}
									//Then make the new console go in, if we are in "new console incoming!" mode (i.e. foe.active > 2, because 2 means "disabled / console offscreen" and 1 means active)
									else if( foe->active > 2 ){
										
										//If the new console incoming animation is finished
										if( foe->active == 3 ){
											
											//Move the console back to its final position
											foe->consoleX = foe->x;
											foe->consoleY = foe->y+32;
											
											//Restore the foe in its normal state (active) as the animation is finished
											foe->active=1;
										}
										//Else, continue the transition anim
										else {
											
											//Wait a few cycles with the console offscreen before moving it back											
											if( foe->active < 21 ){
												//Move the console back in
												foe->consoleX = foe->x; //Disabled the easing in X as it looks ugly, Y only feels better
												foe->consoleY += ( (foe->y+32 - foe->consoleY) >> 2);
											}
											
											//Decrease the anim step counter
											if( foe->active > 3 ){ --foe->active; }
										}
									}
									
									//Reset the TV anim during the transition
									foe->anim=0;
									
									//Update the console sprite onscreen
									m=(40+i)*4; //First, compute the actual OAM index of the sprite representing this foe
									oamSetXY(m, foe->consoleX, foe->consoleY);
									oamSetGfxOffset(m, consoleAnim[foe->consoleAnim]);
								}
								//Else, the current game isn't finished
								else {

									//Decrease our life! (the ticks_decrease value is computed differently when the cart is sticky (normal countdown) or in the air (slower countdown) - see code at the beginning of the main loop 
									if( foe->life > 0 && ticks_decrease ){
										--foe->life;
									}
									
									//Update anim when we reach certain thresold
									if( foe->life == 240 ){
										foe->anim=11;
									}
									else if( foe->life == 220 ){
										foe->anim=10;
									}
									else if( foe->life == 195 ){
										foe->anim=9;
									}
									else if( foe->life == 170 ){
										foe->anim=8;
									}
									else if( foe->life == 145 ){
										foe->anim=7;
									}
									else if( foe->life == 120 ){
										foe->anim=6;
									}
									else if( foe->life == 95 ){
										foe->anim=5;
									}
									else if( foe->life == 70 ){
										foe->anim=4;
									}
									else if( foe->life == 45 ){
										foe->anim=3;
									}
									//For the last step, make the foe blink even if the cart is in the air!
									else if( foe->life <= 20 ){
										//Make the foe blink for its last state before destruction
										if( (ticks & 7) < 4 ){
											foe->anim=2;
										} else {
											foe->anim=1;
										}
									}
									
								}
							}
			
							//If we are not in "transition anim" mode
							if( foe->active == 1 ){
							
								//Update CONSOLE Part
								
								//Update the console positions
								foe->consoleX = foe->x;
								foe->consoleY = foe->y+32;
								
								//Update the console sprite onscreen
								m=(40+i)*4; //First, compute the actual OAM index of the sprite representing this foe
								oamSetXY(m, foe->consoleX, foe->consoleY);
								oamSetGfxOffset(m, consoleAnim[foe->consoleAnim]);
								
								//COLLISION WITH PLAYER
							
								//If player is free floating 
								if( player.sticky == 255 ){
									
									//if collision with player
									//OPTIMIZATION: Manual "inlining" of collision function to save CPU time
									//=> if ((x1 < (x2+w2)) && ((x1+w1) > x2) && (y1 < (h2+y2)) && ((y1+h1) > y2))
									if( (player.x < (foe->x+24)) && ((player.x+16) > foe->x) && (player.y < (foe->y+54)) && (player.y > (foe->y+34)) ){
									
										//Get sticky to the current console we are on
										player.sticky=i;
										
										//Teleport the cartridge into the console cartridge slot
										player.x=foes[player.sticky].x+4;
										player.y=foes[player.sticky].y+33;
										player.speedX=0;
										player.speedY=0;
										//And change its animation to "plugged"
										player.anim=0;
										oamSetGfxOffset(80, playerAnim[player.anim]);
										
										//Update the player sprite position
										oamSetXY(80,  player.x, player.y);
										
										//Update the console sprite onscreen to the first still image of the gameplay
										foe->anim=13;
										
										//Play Sound
										spcEffect(8, MOD_AUDIO_LIFEUP, 248);
									}
									
								}
							}
							
							//TV UPDATE

							//Update the foe sprite onscreen
							m=(30+i)*4; //First, compute the actual OAM index of the sprite representing this foe
							oamSetXY(m, foe->x, foe->y);
							oamSetGfxOffset(m, foeAnim[foe->anim]);
						}
						//Else, the foe is DEAD!
						else {
							
							//Stop music (silence it instead of stopping it, as the spcStop() function can crash the audio driver sometimes)
							spcSetModuleVolume(0);
							
							//Make the foe disappear (tv and console)
							oamSetVisible((30+i)*4, OBJ_HIDE);
							oamSetVisible((40+i)*4, OBJ_HIDE);
							
							//Spawn explosions (with a slight delay for better visual effect)
							spawnBoom(foe->x-1, foe->y-3, 0);
							spawnBoom(foe->x+6, foe->y+23, 2);
							spawnBoom(foe->x-3, foe->y+9, 4);
							spawnBoom(foe->x+2, foe->y+42, 6);
							spawnBoom(foe->x+8, foe->y+14, 8);
							spawnBoom(foe->x, foe->y+32, 10);
							
							//Make the screen shake
							screenshake=16;
							
							//Go to GAME OVER state
							STATE=2;
							//And set the game over animation duration
							ticks_anim=120;
						}
					}					
				}
				
				
				
				
				//=========== PLAYER ===============

				
				//If the player isn't stickyied into a console
				if( player.sticky == 255 ){
				
					//Oh, gravity! (use the personal ticks counter of the player)
					if( !(player.graviticks % 6) ){ //We have to use a modulo here, as the bitmasks don't allow us to have a value that "feels good" when we play :)
						//Increase player Y speed so he goes down!
						++player.speedY;
					}
				
					//Horizontal movement
					//Move left
					if(pad0 & KEY_LEFT) {
						player.speedX=-2;
					}
					//Move Right
					else if(pad0 & KEY_RIGHT) {
						player.speedX=2;
					}
					//Else, no movement in X
					else {
						player.speedX=0;
					}
				
					//Update player position
					player.x += player.speedX;
					player.y += player.speedY;
				
					//If the player goes out in X
					if( player.x < SCREEN_LEFT ){
						player.x=SCREEN_LEFT;
						player.speedX=0;
					}
					else if( player.x > SCREEN_RIGHT-26 ){
						player.x=SCREEN_RIGHT-26;
						player.speedX=0;
					}
				
					//If the player goes out in Y (or roll on the other side from top due to excessive Y speed)
					//Indeed, if the player Y position is between 240 and 255, it means that it overflowed from top, as a regular fall down will be stopped around 208-220)
					if( player.y < SCREEN_TOP || player.y > 240 ){
						player.y=SCREEN_TOP;
						player.speedY=0;
					}
					//Else, if the player has fallen on the floor
					else if( player.y >= 208 ){
						
						//Stop music (silence it instead of stopping it, as the spcStop() function can crash the audio driver sometimes)
						spcSetModuleVolume(0);
						
						//Spawn explosions
						spawnBoom(player.x-4, player.y-21, 0);
						spawnBoom(player.x-5, player.y-14, 3);
						spawnBoom(player.x+2, player.y-25, 6);
						spawnBoom(player.x-2, player.y-18, 9);
						
						//Stop player cartridge and put it offscreen
						player.y=224;
						player.speedY=0;
						
						//Make the screen shake
						screenshake=12;
						
						//Go to GAME OVER state
						STATE=2;
						//And set the game over animation duration
						ticks_anim=100;
					}
				}	
				//Else, the player is plugged into a console
				else {
					
					//PLAYER FOLLOWS CONSOLE
					player.x=foes[player.sticky].x+4;
					player.y=foes[player.sticky].y+33;
				}
				
				//PLAYER JUMP
				//If button is pressed
				if( pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A ){
					
					//Only once per button press
					if( pressedJUMP == 0 ){
						
						//If the player is stickyied into a console (I didn't merge this "if" statement with the previous one, as we need to catch every "first press" here, whether we're into a console or not)
						if( player.sticky != 255 ){
						
							//Make the player go above the console so it won't be stickyied back to it immediatedly
							//(add the Y speed of the foe were are stickyed to so it's doesn't catch us back when moving upwards!)
							player.y -= 4-foes[player.sticky].speedY;
							
							//Make the player Jump
							player.speedY=-3;
							
							//Prevent it from going out of bounds on top of screen (or roll on the other side due to excessive Y speed)
							if( player.y < SCREEN_TOP || player.y > 240 ){
								player.y=SCREEN_TOP;
								player.speedY=0;
							}
							
							//Reset ticks to have an identical jump eveytime (gravity-wise)
							player.graviticks=0;
							
							//Update the console we were plugged to
							//Reset it's life to full
							foes[player.sticky].life=241;
							//And change its anim to "waiting / no cart"
							foes[player.sticky].anim=11;
							
							//Make the player free!
							player.sticky=255;
							
							//And change it's animation to "unplugged"
							player.anim=1;
							oamSetGfxOffset(80, playerAnim[player.anim]);
							
							//Play Sound
							spcEffect(8, MOD_AUDIO_JUMP, 248);
							
							//Do it only once per button press
							pressedJUMP=1;
						}
					}
					//Progressive jump height (the more you hold button down, the higher you get!
					else if( pressedJUMP < 7){
						
						//Every 2 ticks, increase the jumping speed (for a very limited time of course!)
						if( !(player.graviticks & 1) ){
							--player.speedY;
						}
						
						//Limit the duration of the repeated button press
						++pressedJUMP;
					}
				}
				else {
					//Mark down the button as released
					pressedJUMP=0;
				}
			
				//Update the player sprite position
				oamSetXY(80,  player.x, player.y);
				
				
				//=========== BOOMS & SCREENSHAKE ===============
				
				//Call the dedicated function to handle explosions and screenshake
				updateBoom();
				
				
				//=========== SCORE & NEXT LEVEL ===============	
				
				//if the score needs to be refreshed
				if( refreshScore != 0 ){
					
					//If we are not in survival mode
					if( level != 200 ){
						//Update the display of current score / foes cleared (update numbers only, the text label is set during gameStart init function)
						if( score < 10 ){
							consoleDrawText(17,0,"%d", score);
						} else {
							consoleDrawText(16,0,"%d", score);
						}
					} 
					//Else we are in survival mode (so score number is located in a different position)
					else {
						//Update the display of current score / foes cleared (update numbers only, the text label is set during gameStart init function)
						if( score < 10 ){
							consoleDrawText(19,0,"%d", score);
						} else {
							consoleDrawText(18,0,"%d", score);
						}
					}
					
					//Do it only once to avoid overloading the CPU (the text printing function are VERY taxing on the CPU, so do it only when needed)
					refreshScore=0;
				}
				
				//If we completed the level (cleared all consoles) - expect for survival mode! (level 200)
				if( foesRemaining == 0 && level != 200 ){
				
					//Stop music (silence it instead of stopping it, as the spcStop() function can crash the audio driver sometimes)
					spcSetModuleVolume(0);
					
					//Go to LEVEL COMPLETE state
					STATE=3;
					
					//And set the level complete animation duration
					//Did we finish all the levels ?
					if( level == 20 ){
						//If yes, longer animation time for the level complete state
						ticks_anim=420;
					} else {
						//Else, normal animation time
						ticks_anim=180;
					}
					
					//Play Sound
					spcEffect(6, MOD_AUDIO_HIGHSCORE, 248);
					spcEffect(6, MOD_AUDIO_HIGHSCORE, 248);
				}
				
				//=========== MISC ===============	
				
				//Pause the game when START is pressed
				if( (pad0 & KEY_START) ){

					//Can press only once
					if( pressedSTART == 0 ){
						
						//Pause the game
						isPaused=1;
						
						//Dim the light and mark the game as Paused
						setBrightness(10);
						consoleDrawText(14,14,"PAUSE");
						
						//Mute music (actually, only silence it, because stopping it can make the sound driver get stuck on a note)
						spcSetModuleVolume(0);
						
						//Set the key as pressed
						pressedSTART=1;
					}
				}
				//Else, mark the key as released
				else {
					pressedSTART=0;
				}
				
				//PAUSE / UNPAUSE MUSIC music with SELECT button
				//If select button is pressed
				if( pad0 &  KEY_SELECT){
					
					//Only once per button press
					if( pressedSELECT == 0 ){
						
						//Pause the music if it was playing
						if( musicPaused == 0 ){
							//Mute music (actually, only silence it, because stopping it can make the sound driver get stuck on a note)
							spcSetModuleVolume(0);
							//And register the current paused state
							musicPaused=1;
						}
						//else unpause it!
						else {
							//Unpause the music
							spcSetModuleVolume(100);
							//And register the current unpaused state
							musicPaused=0;
						}
						
						//Do it only once per button press
						pressedSELECT=1;
					}
				}
				else {
					//Mark down the button as released
					pressedSELECT=0;
				}
				
				
				
			}
			
			//ELSE, THE GAME IS PAUSED
			else {
				
				//Unpause the game when START is pressed
				if( pad0 & KEY_START ){

					//Can press only once
					if( pressedSTART == 0 ){
						
						//Unpause the game
						isPaused=0;
						
						//Restore the light and clear the message
						setBrightness(15);
						consoleDrawText(14,14,"     ");
						
						//Restore music volume (i.e. unsilence it) if it's not paused permanently
						if( musicPaused == 0 ){
							spcSetModuleVolume(100);
						}
						
						//Set the key as pressed
						pressedSTART=1;
					}
				}
				//Else, mark the key as released
				else {
					pressedSTART=0;
				}				
			}
		}
		
		
		//===============================
		//======= GAME OVER STATE ======
		//===============================
		else if( STATE == 2 ){
			
			//If the game over anim is playing
			if( ticks_anim > 0 ){
				
				//Decrease countdown
				--ticks_anim;
				
				//Game Over Anim steps
				if( ticks_anim == 30 ){
					
					//Display game over message
					//Set the BG scroll to display "Game Over" message
					bgSetScroll(0, 0, 0);
					//And display this bg!
					bgSetEnable(0);
				}
				else if( ticks_anim == 10 ){
					
					//If we are in survival mode
					if( level == 200 ){
					
						//Did we make a new record?
						if( score > highscore ){
							//Record the record!
							highscore=score;
							
							//And displays a message
							consoleDrawText(11,2,"NEW RECORD!");
							
							//Play Sound
							spcEffect(6, MOD_AUDIO_HIGHSCORE, 248);
							spcEffect(6, MOD_AUDIO_HIGHSCORE, 248);
						}
						//Else, display current record
						else {
							//Display the current record
							if( highscore < 10 ){
								consoleDrawText(10,2,"HIGHSCORE:0%d", highscore);
							} else {
								consoleDrawText(10,2,"HIGHSCORE:%d", highscore);
							}
						}
					}
				}
				else if( ticks_anim == 0 ){
					
					//Display the menu elements
					consoleDrawText(12, 25, "> RETRY");
					consoleDrawText(12, 26, "  QUIT ");
					
					//And set the selection to the first menu item
					menu_step=0;
				}
				
			}
			//Else, Game Over animation is finished
			else {
				
				//Move in the menu using the direction keys
				//When any button, start, or up, down is pressed
				if( pad0 & KEY_UP || pad0 & KEY_DOWN || pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A || pad0 & KEY_START ){
					
					//LIMITED ACTIONS
					//Only once per button press
					if( pressedJUMP == 0 ){
					
						//Move in the menu up and down
						//Up
						if( pad0 & KEY_UP ){
							//Clear previous cursor display
							consoleDrawText(12, 25+menu_step, " ");
							
							//Decrease menu option (and wrap)
							if( menu_step > 0 ){ --menu_step; }
							else { menu_step=1; }
							
							//Update menu option cursor display
							consoleDrawText(12, 25+menu_step, ">");
						}
						//Down
						else if( pad0 & KEY_DOWN ){
							//Clear previous cursor display
							consoleDrawText(12, 25+menu_step, " ");
							
							//Increase menu option (and wrap)
							if(  menu_step  < 1 ){ ++menu_step; }
							else {  menu_step=0; }
							
							//Update menu option cursor display
							consoleDrawText(12, 25+menu_step, ">");
						}
						
						//If an action button is pressed
						if( pad0 & KEY_START || pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A ){
							
							//Menu Item 0: RETRY (start level again)
							if( menu_step == 0 ){
								
								//Fade out
								setFadeEffect(FADE_OUT);
								
								//Set forced blanking for unlimited VRAM access
								setBrightness(0);
								
								//Restart the game
								startGame();
							}
							
							//Menu Item 1: QUIT (back to menu)
							else if( menu_step == 1 ){
								
								//Fade out
								setFadeEffect(FADE_OUT);
								
								//Set forced blanking for unlimited VRAM access
								setBrightness(0);
					
								//Load the title screen Tileset and its palette (on slot 1 and after, as palette slot 0 is for text)
								bgInitTileSet(1, &bg_titleGFX, &bg_titlePAL, 1, (&bg_titleGFX_end - &bg_titleGFX), 16 << 1, BG_16COLORS, 0x2000);
								bgInitMapSet(1, &bg_titleMAP, (&bg_titleMAP_end - &bg_titleMAP), SC_32x64, 0x1000);
								
								//Set the state to title screen
								STATE=0;
								
								//Unpause the music (won't affect title screen, but will turn music back on if player launches a new game)
								musicPaused=0;
								
								//Init the title screen variables
								ticks_anim=560;
								ticks=0;
								pressedJUMP=10; //Not 1 because of the "progressive jump" feature, that can increase this variable up to 7
								menu_step=0;
								
								//Change the title screen logo color to black so it can appear fading in red during the intro anim
								//Write the adress of the color to change to the dedicated register (palette1 - color 2)
								REG_CGADD = 0x12; 
								//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
								*CGRAM_PALETTE = RGB5(0, 0, 0) & 0xFF; 
								*CGRAM_PALETTE = RGB5(0, 0, 0) >> 8;
								
								//Change the "intro screen text" colors (3 colors: 5-6-7) to black so they can appear fading in red during the intro anim
								//Write the adress of the color to change to the dedicated register (palette1 - color 5)
								REG_CGADD = 0x15; 
								//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
								*CGRAM_PALETTE = RGB5(0, 0, 0) & 0xFF; 
								*CGRAM_PALETTE = RGB5(0, 0, 0) >> 8;
								//Write the adress of the color to change to the dedicated register (palette1 - color 6)
								REG_CGADD = 0x16; 
								//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
								*CGRAM_PALETTE = RGB5(0, 0, 0) & 0xFF; 
								*CGRAM_PALETTE = RGB5(0, 0, 0) >> 8;
								//Write the adress of the color to change to the dedicated register (palette1 - color 7)
								REG_CGADD = 0x17; 
								//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
								*CGRAM_PALETTE = RGB5(0, 0, 0) & 0xFF; 
								*CGRAM_PALETTE = RGB5(0, 0, 0) >> 8;
								
								
								//Hide the BG with Game Over / Well Done messages
								bgSetDisable(0);
								//And reset its scroll back to "Game Over"
								bgSetScroll(0, 0, 0);
								
								//Reset the TV gameplay BG color to its starting value
								//Write the adress of the color to change to the dedicated register (palette 9 - color 16)
								REG_CGADD = 0x9F; 
								//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
								*CGRAM_PALETTE = RGB5(9, 9, 9) & 0xFF; 
								*CGRAM_PALETTE = RGB5(9, 9, 9) >> 8;
								
								//Clear the color change buffer
								colorChangeADDR=0;
								colorChangeDATA=0;
							
								//Clear the BG3 to erase all text display
								//Fill the text map variable with 0x00 (empty) tile
								for (m=0; m < 0x800; ++m){
									pvsneslibfont_map[m] = 0x00;
								}
								//And send the map to VRAM into the location used by PVSNESlib's text engine (read console.h for more info)
								dmaCopyVram(pvsneslibfont_map, 0x800, 0x800);
								
								//Change the text color back to white
								//Write the adress of the color to change to the dedicated register (palette0 - color 1)
								REG_CGADD = 0x01; 
								//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequential writes)
								*CGRAM_PALETTE = RGB5(31, 31, 31) & 0xFF; 
								*CGRAM_PALETTE = RGB5(31, 31, 31) >> 8;

								//Clear Sprites
								for( i = 0 ; i < 10 ; ++i ){
									
									//Hide the TV sprites (and put them offscreen)
									oamSetXY((30+i)*4, 0, 224);
									oamSetVisible((30+i)*4, OBJ_HIDE);
									
									//Hide the Console sprites (and put them offscreen)
									oamSetXY((40+i)*4, 0, 224);
									oamSetVisible((40+i)*4, OBJ_HIDE);
									
									//Hide the Boom sprites (and put them offscreen)
									oamSetXY((5+i)*4, 0, 224);
									oamSetVisible((5+i)*4, OBJ_HIDE);
								}
								
								//Hide the player sprite (and put it offscreen)
								oamSetXY(80, 0, 224);
								oamSetVisible(80, OBJ_HIDE);
								
								//Fade in
								setFadeEffect(FADE_IN);
							}
	
						}
						
						//Do it only once per button press
						pressedJUMP=10;  //Not 1 because of the "progressive jump" feature, that can increase this variable up to 7
					}
				}
				else {
					//Mark down the button as released
					pressedJUMP=0;
				}
			}
			
			//GENERAL ANIMATION
			
			//Update ticks counter using the ticks_anim instead or regular ticks
			ticks_mid=!(ticks_anim&3);
			
			//Call the dedicated function to handle explosions and screenshake
			updateBoom();
		}
		
		//===============================
		//===== LEVEL COMPLETE STATE ====
		//===============================
		else if( STATE == 3 ){
			
			//If the level complete anim is playing
			if( ticks_anim > 0 ){
				
				//Decrease countdown
				--ticks_anim;
				
				//All levels completed (i.e. game ending) anim steps (duration is longer than regular level complete state)
				if( ticks_anim == 370 ){
					
					//Display level complete message
					//Set the BG scroll to display "Well Done" message
					bgSetScroll(0, 0, 256);
					//And display this bg!
					bgSetEnable(0);
				}
				else if( ticks_anim == 340 ){
					
					//Display a game ending congratulations message	(and tell that we are going to survival mode next) 1/3
					consoleDrawText(9,14,"CONGRATULATIONS!");
				}
				else if( ticks_anim == 300 ){
					
					//Display a game ending congratulations message	(and tell that we are going to survival mode next) 2/3
					consoleDrawText(10,16,"You completed");
					consoleDrawText(10,17,"all the levels");
				}
				else if( ticks_anim == 260 ){
					
					//Display a game ending congratulations message	(and tell that we are going to survival mode next) 3/3
					consoleDrawText(10,19,"Now, let's try");
					consoleDrawText(10,20,"SURVIVAL MODE!");
				}
				//Normal Level complete anim steps (starting a frame 180, everything before is unique to the game ending anim)
				else if( ticks_anim == 130 ){
					
					//Display level complete message
					//Set the BG scroll to display "Well Done" message
					bgSetScroll(0, 0, 256);
					//And display this bg!
					bgSetEnable(0);
				}
				else if( ticks_anim == 30 ){
					//Fade out
					setFadeEffect(FADE_OUT);
					
					//Set forced blanking for unlimited VRAM access
					setBrightness(0);
				}
				
				//Keep on updating the foes movement (without any other gameplay element)
				//Foe each foe
				for( i = 0 ; i < 10 ; ++i ){
					
					//Get current foe
					foe=&foes[i];
					
					//If the foe is active
					if( foe->active != 0 ){
						
						//Update TV part
						
						//Update the foe positions
						
						//X position
						//Normal mode
						if( foe->circularX == 255 ){
							//Move the foe by its current speed
							foe->x += foe->speedX;
						}
						//Circular mode
						else {
							//Increase the current LUT index by the foe speed
							foe->circularX += foe->speedX;
							//Make it loop around the LUT if needed (the first 8 indexes of the LUT are junk data to allow for looping even with negative speed up to -8)
							if( foe->circularX >= 248 ){
								foe->circularX -= 240;
							}
							if( foe->circularX < 8 ){
								foe->circularX += 240;
							}
							//And apply the current position from the LUT containing precomputed circular positions
							//If we have to divide (or actually bitshift) the radius, do it now
							if( foe->circularXradius != 0 ){
								foe->x = foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
							}
							//Else, use the LUT position without dividing it
							else {
								foe->x = foe->circularXorigin+LUTcircleX[foe->circularX];
							}
						}
						
						//Y position
						//Normal mode
						if( foe->circularY == 255 ){
							//Move the foe by its current speed
							foe->y += foe->speedY;
						}
						//Circular mode
						else {
							//Increase the current LUT index by the foe speed
							foe->circularY += foe->speedY;
							//Make it loop around the LUT if needed (the first 8 indexes of the LUT are junk data to allow for looping even with negative speed up to -8)
							if( foe->circularY >= 248 ){
								foe->circularY -= 240;
							}
							if( foe->circularY < 8 ){
								foe->circularY += 240;
							}
							//And apply the current position from the LUT containing precomputed circular positions
							//If we have to divide (or actually bitshift) the radius, do it now
							if( foe->circularYradius != 0 ){
								foe->y = foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
							}
							//Else, use the LUT position without dividing it
							else {
								foe->y = foe->circularYorigin+LUTcircleY[foe->circularY];
							}
						}
						
						//If the foes goes out in X
						if( foe->x < SCREEN_LEFT ){
							foe->x=SCREEN_LEFT;
							foe->speedX=-foe->speedX;
						}
						else if( foe->x > SCREEN_RIGHT-32 ){
							foe->x=SCREEN_RIGHT-32;
							foe->speedX=-foe->speedX;
						}
					
						//If the foes goes out in Y
						if( foe->y < SCREEN_TOP){
							foe->y=SCREEN_TOP;
							foe->speedY=-foe->speedY;
						}
						else if( foe->y > SCREEN_BOTTOM-64 ){
							foe->y=SCREEN_BOTTOM-64;
							foe->speedY=-foe->speedY;
						}
			
						//Update the foe sprite onscreen
						m=(30+i)*4; //First, compute the actual OAM index of the sprite representing this foe
						oamSetXY(m, foe->x, foe->y);
						oamSetGfxOffset(m, foeAnim[foe->anim]);
							
						//Update the console positions only for the foes that are still active! (the other are "active but disabled / waiting for new console" with their consoles located offscreen)
						if( foe->active == 1 ){
							foe->consoleX = foe->x;
							foe->consoleY = foe->y+32;
	
							//Update the console sprite onscreen
							m=(40+i)*4; //First, compute the actual OAM index of the sprite representing this foe
							oamSetXY(m, foe->consoleX, foe->consoleY);
							oamSetGfxOffset(m, consoleAnim[foe->consoleAnim]);
						}
					}
				}
				
				//PLAYER FOLLOWS CONSOLE
				player.x=foes[player.sticky].x+4;
				player.y=foes[player.sticky].y+33;
				
				//Update the player sprite position
				oamSetXY(80,  player.x, player.y);
			}
			//Else, Level Complete animation is finished
			else {
				
				//We go to the next level automatically!
				
				//If we finished all the levels => survival mode!
				if( level == 20 ){
					//Go to survival mode
					level = 200;
				}
				//Else, next level!
				else {
					//Increase level
					++level;
				}

				//Restart the game
				startGame();
			}
		}
		
		//===============================
		//======= TITLE SCREEN STATE ======
		//===============================
		else if( STATE == 0 ){
			
			//Call the separate function that handle everything related to the title screen
			updateTitle();
		}
		
		
		//End of the game logic, wait for the next VBL (sprites will be updated by the PPU)
		WaitForVBlank();
		
		//Update Audio (beware, if the game logic take too much time and the game lags, doing it after the game logic can crash the whole game if you are using the streaming sound features of the SNESmod audio driver!)
		//And even if you don't use the streaming function, if the game lags it can slowdown musicplayback. So, for this game, I'm updating audio right after the beginning of the new VBLANK, i.e. BEFORE all the game logic
		spcProcess();
	}
	return 0;
}

//COLLISION CHECK
//This function perform a simple rectangle-rectangle collision (AABB)
//Returns 1 if collision, or 0 if no collision
//Params (x position A, y position A, width A, height A, x position B, y position B, width B, height B)
u8 isCollision( u8 x1, u8 y1, u8 w1, u8 h1, u8 x2, u8 y2, u8 w2, u8 h2 ){

	//Check if the two rectangles are overlapping using their coordinates
	if ((x1 < (x2+w2)) && ((x1+w1) > x2) && (y1 < (h2+y2)) && ((y1+h1) > y2)){
		return 1;
	} else {
		return 0;
	}
};



//====================================
//=========== EXPLOSIONS =============
//====================================

//SPAWN EXPLOSION FUNCTION
//This function spawn a new explosion, if there are slot available in the "boom" array
//Params (posX, posY, delay to wait before actually launching the explosion)
void spawnBoom(u8 posX, u8 posY, u8 delay){
	
	//For each Boom
	for( l = 0 ; l < 10 ; ++l ){
		
		//Get current boom
		boom=&booms[l];

		//If the boom is not active
		if( boom->active == 0 ){
			
			//Mark it as active
			boom->active = 1;
			
			//Set its positions
			boom->x=posX;
			boom->y=posY;
			//And speeds
			boom->speedX=0;
			boom->speedY=0;
			
			//Set its delay
			boom->delay=delay;
			
			//Define sprites parameters for the current boom so it's displayed on screen
			//use foe index (l) to flip the explosion in X ou Y so it doesn't look always the same!
			oamSet((5+l)*4, boom->x, boom->y, 2, (l & 1), ((l & 3) > 1), boomAnim[boom->anim], 0);
			
			//Display the boom only if we don't have to "wait for it" (else the delay will be decreased in the main loop)
			if( delay == 0 ){
				//Show the sprite
				oamSetVisible((5+l)*4, OBJ_SHOW);
				
				//Play Sound
				spcEffect(8, MOD_AUDIO_EXPLOSION, 248);
			}
			
			//Stop the loop as we have already generated a boom!
			break;
		}
		
	}
}

//UPDATE EXPLOSION & SCREENSHAKE FUNCTION
//This functions takes care of managing the explosions (so we can call it from gameplay, gameover, or any other screen easily)
void updateBoom(){
	
	//===== EXPLOSION =====
	
	//Foe each boom
	for( i = 0 ; i < 10 ; ++i ){
		
		//Get current boom
		boom=&booms[i];
		
		//If the boom is active
		if( boom->active != 0 ){
			
			//if the boom isn't "delayed"
			if( boom->delay == 0 ){
			
				//Update the boom positions
				boom->x += boom->speedX;
				boom->y += boom->speedY;
				
				//Update boom anim
				if( ticks_mid ){
					++boom->anim;
					//Kill the boom if anim is finished
					if( boom->anim == 9 ){ 
						boom->active=0;
						boom->anim=0; 
						boom->x=0;
						boom->y=224;
						oamSetVisible( (5+i)*4, OBJ_HIDE);
					}
				}
				
				//Update the boom sprite onscreen
				m=(5+i)*4; //First, compute the actual OAM index of the sprite representing this boom
				oamSetXY(m, boom->x, boom->y);
				oamSetGfxOffset(m, boomAnim[boom->anim]);
			}
			//Else, decrease the delay counter
			else {
				//If it's the last step of the waiting delay, we show the sprite and make a boom sound!
				if( boom->delay == 1){
					//Show the sprite
					oamSetVisible((5+i)*4, OBJ_SHOW);
					
					//Play Sound
					spcEffect(3, MOD_AUDIO_EXPLOSION, 248);
				}
				
				//decrease delay
				--boom->delay;
			}
			
		}					
	}
	
	//===== SCREENSHAKE =====
	
	//Do some screenshake (if activated) - shake the BG
	if ( screenshake != 0 && ticks_mid ){
		
		//Last Shake
		if ( screenshake == 1 ){
			//Reset Screen in normal state
			bgSetScroll(0, 0, 0);
			bgSetScroll(1, 0, 0);
			bgSetScroll(2, 0, -2);
		}
		//else shake the screen!
		else {
			//Move Down
			if( (screenshake & 1) == 0 ){
				bgSetScroll(0, 0, 1);
				bgSetScroll(1, 0, 1);
				bgSetScroll(2, 0, -3);
			}
			//Move Up
			else {
				bgSetScroll(0, 0, -1);
				bgSetScroll(1, 0, -1);
				bgSetScroll(2, 0, -1);
			}
		}

		//Decrease Shake Counter
		--screenshake;
	}
}



//====================================
//=========== LEVEL DESIGN ============
//====================================

//BUILD LEVEL FUNCTION
//This function defines the parameters for each level of the game
//In order to stay below the 32k per function limit of the compiler, this function is actually divided in 2 parts (the second function is called at the end of the first one)
void buildLevel(){
	
	//We start from a blank state (all foes disabled), so we only define what we need to play with in each level!
	
	//Tutorial!
	//===== LEVEL 1 ======
	if( level == 1 ){
	
		//Number of foes (goal)
		foesStock=1;
		foesRemaining=2+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init foes
		for( i = 0 ; i < 2 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->x=60+(i*120);
			foe->y=158;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player outside a console slot
		player.sticky=255;
		player.x=foes[0].x+4;
		player.y=foes[0].y-100;
		player.anim=1;
		
	}
	
	//4 static TVs
	//===== LEVEL 2 ======
	else if( level == 2 ){
	
		//Number of foes (goal)
		foesStock=4;
		foesRemaining=4+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=2;
		
		//Init foes
		for( i = 0 ; i < 4 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			//Different pos / speed values for each foe
			if( i == 0 ){
				foe->x=50;
				foe->y=28;
			} else if ( i == 1 ){
				foe->x=180;
				foe->y=28;
			} else if ( i == 2 ){
				foe->x=50;
				foe->y=158;
			} else if ( i == 3 ){
				foe->x=180;
				foe->y=158;
			}
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
		
	}
	
	//Infinity in the middle
	//===== LEVEL 3 ======
	else if( level == 3 ){
	
		//Number of foes (goal)
		foesStock=4;
		foesRemaining=3+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=2;
		
		//Init foes
		i=0;
		
		//Bouncing foe
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->circularX=8;
		foe->circularXorigin=112;
		foe->circularXradius=0;
		foe->circularY=8;
		foe->circularYorigin=88;
		foe->circularYradius=0;
		foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
		foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
		foe->speedX=1;
		foe->speedY=2;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Still foe left
		++i;
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->x=8;
		foe->y=88;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
	
		//Still foe right
		++i;
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->x=216;
		foe->y=88;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
	
		//Init player in a console slot
		player.sticky=1;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//Two floating TVs!
	//===== LEVEL 4 ======
	else if( level == 4 ){
	
		//Number of foes (goal)
		foesStock=5;
		foesRemaining=2+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		i=0;
		//Free floating foe X
		foe=&foes[0];
		//Set its vars
		foe->active=1;
		foe->x=110;
		foe->y=100;
		foe->speedX=1;
		foe->speedY=-1;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Free floating foe X
		foe=&foes[++i];
		//Set its vars
		foe->active=1;
		foe->x=110;
		foe->y=100;
		foe->speedX=-1;
		foe->speedY=1;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//7 Tvs on the floor
	//===== LEVEL 5 ======
	else if( level == 5 ){
	
		//Number of foes (goal)
		foesStock=3;
		foesRemaining=7+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=2;
		
		//Init foes
		for( i = 0 ; i < 7 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->x=4+(i*36);
			foe->y=158;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
		
	}
	
	//Easy Wheel
	//===== LEVEL 6 ======
	else if( level == 6 ){
	
		//Number of foes (goal)
		foesStock=5;
		foesRemaining=5+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=2;
		
		//Init foes
		for( i = 0 ; i < 5 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->circularX=8+(48*i);
			foe->circularXorigin=112;
			foe->circularXradius=0;
			foe->circularY=8+(48*i);
			foe->circularYorigin=78;
			foe->circularYradius=0;
			foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
			foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
			foe->speedX=1;
			foe->speedY=1;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}

		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//Fast moving bridge
	//===== LEVEL 7 ======
	else if( level == 7 ){
	
		//Number of foes (goal)
		foesStock=2;
		foesRemaining=3+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init foes
		for( i = 0 ; i < 2 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->x=10+(i*208);
			foe->y=60;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Free floating foe X
		foe=&foes[++i];
		//Set its vars
		foe->active=1;
		foe->x=110;
		foe->y=140;
		foe->speedX=2;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
		
	}
	
	//4 on the ground, 2 in the sky
	//===== LEVEL 8 ======
	else if( level == 8 ){
			
		//Init level stock and goal
		foesStock=3;
		foesRemaining=6+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=2;
		decrease=2;
		
		//Init foes
		for( i = 0 ; i < 4 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->x=6+(i*70);
			foe->y=158;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Free floating foe Y
		foe=&foes[++i];
		//Set its vars
		foe->active=1;
		foe->x=110;
		foe->y=80;
		foe->speedY=1;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Free floating foe X
		foe=&foes[++i];
		//Set its vars
		foe->active=1;
		foe->x=30;
		foe->y=40;
		foe->speedX=1;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Init player in a console slot
		player.sticky=1;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//Bouncing circular on 2 sides
	//===== LEVEL 9 ======
	else if( level == 9 ){
	
		//Number of foes (goal)
		foesStock=5;
		foesRemaining=2+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=2;
		decrease=1;
		
		//Init foes
		i=0;
		
		//Bouncing foe left
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->circularX=8;
		foe->circularXorigin=32;
		foe->circularXradius=0;
		foe->circularY=8;
		foe->circularYorigin=74;
		foe->circularYradius=0;
		foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
		foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
		foe->speedX=1;
		foe->speedY=1;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Init foes
		++i;
	
		//Bouncing foe right
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->circularX=158;
		foe->circularXorigin=192;
		foe->circularXradius=0;
		foe->circularY=158;
		foe->circularYorigin=74;
		foe->circularYradius=0;
		foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
		foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
		foe->speedX=-1;
		foe->speedY=-1;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
	
	
		//Init player in a console slot
		player.sticky=1;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//10 TVs!
	//===== LEVEL 10 ======
	else if( level == 10 ){
	
		//Number of foes (goal)
		foesStock=0;
		foesRemaining=10+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=2;
		
		//Init foes
		for( i = 0 ; i < 10 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			if ( i <= 2 ){ 
				foe->x=40+(i*72);
				foe->y=8;
			} else if( i > 2 && i < 7 ){
				foe->x=4+((i-3)*72);
				foe->y=83;
			} else {
				foe->x=40+((i-7)*72);
				foe->y=158;
			}
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player outside a console slot
		player.sticky=255;
		player.x=foes[4].x+4;
		player.y=foes[4].y-30;
		player.anim=1;
	}
	
	//Three TV moving in X
	//===== LEVEL 11 ======
	else if( level == 11 ){
	
		//Number of foes (goal)
		foesStock=5;
		foesRemaining=3+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init foes
		for( i = 0 ; i < 3 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->y=10+(i*72);
			//Different pos / speed values for each foe
			if( i == 0 ){
				foe->x=110;
				foe->speedX=1;
			} else if ( i == 1 ){
				foe->x=60;
				foe->speedX=-2;
			} else if ( i == 2 ){
				foe->x=200;
				foe->speedX=-1;
			}
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
		
	}
		
	//To stay under the 32k per function limit of the compiler, this function was cut in two parts.
	else {
		//If none of the other levels was activated, call the second part of the function to test the remaining levels
		buildLevel2();
	}
}
void buildLevel2(){
	
	//Single TV Jump
	//===== LEVEL 12 ======
	if( level == 12 ){
	
		//Number of foes (goal)
		foesStock=2;
		foesRemaining=1+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init index
		i=0;
		
		//Free floating foe X
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->x=110;
		foe->y=110;
		foe->speedX=1;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//4 Tvs moving in Y
	//===== LEVEL 13 ======
	else if( level == 13 ){
	
		//Number of foes (goal)
		foesStock=4;
		foesRemaining=4+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init foes
		for( i = 0 ; i < 4 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->x=16+(i*64);
			//Different pos / speed values for each foe
			if( i == 0 ){
				foe->y=150;
				foe->speedY=-2;
			} else if ( i == 1 ){
				foe->y=120;
				foe->speedY=1;
			} else if ( i == 2 ){
				foe->y=40;
				foe->speedY=-1;
			} else if ( i == 3 ){
				foe->y=80;
				foe->speedY=2;
			}
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player outside a console slot
		player.sticky=255;
		player.x=foes[1].x+4;
		player.y=foes[1].y-80;
		player.anim=1;
	}
	
	//The Totem!
	//===== LEVEL 14 ======
	else if( level == 14 ){
	
		//Number of foes (goal)
		foesStock=5;
		foesRemaining=3+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init foes
		for( i = 0 ; i < 3 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->x=110;
			foe->y=10+(i*72);
			foe->speedX=1;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
		
	}
	
	//Five static TVs
	//===== LEVEL 15 ======
	else if( level == 15 ){
	
		//Number of foes (goal)
		foesStock=5;
		foesRemaining=5+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init foes
		for( i = 0 ; i < 5 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			//Different pos / speed values for each foe
			if( i == 0 ){
				foe->x=20;
				foe->y=18;
			} else if ( i == 1 ){
				foe->x=210;
				foe->y=18;
			} else if ( i == 2 ){
				foe->x=20;
				foe->y=158;
			} else if ( i == 3 ){
				foe->x=210;
				foe->y=158;
			} else if ( i == 4 ){
				foe->x=110;
				foe->y=88;
			}
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//4 in the sky, with a moving one underneath
	//===== LEVEL 16 ======
	else if( level == 16 ){
	
		//Number of foes (goal)
		foesStock=2;
		foesRemaining=5+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=2;
		
		//Init foes
		for( i = 0 ; i < 4 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->x=16+(i*64);
			foe->y=15;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Free floating foe X
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->x=110;
		foe->y=130;
		foe->speedX=3;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Init player in a console slot
		player.sticky=3;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//Windmill
	//===== LEVEL 17 ======
	else if( level == 17 ){
	
		//Number of foes (goal)
		foesStock=3;
		foesRemaining=5+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init foes
		for( i = 0 ; i < 3 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->circularX=8+(80*i);
			foe->circularXorigin=112;
			foe->circularXradius=0;
			foe->circularY=8+(80*i);
			foe->circularYorigin=78;
			foe->circularYradius=0;
			foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
			foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
			foe->speedX=1;
			foe->speedY=1;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init foes
		for( i = 3 ; i < 5 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->circularX=8+(120*i);
			foe->circularXorigin=112;
			foe->circularXradius=2;
			foe->circularY=8+(120*i);
			foe->circularYorigin=78;
			foe->circularYradius=2;
			foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
			foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
			foe->speedX=-2;
			foe->speedY=-2;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//LEVEL 18 is with the survival mode (see LEVEL 200 at the bottom of this loooong if sequence)
	
	//Three moving points!
	//===== LEVEL 19 ======
	else if( level == 19 ){
	
		//Number of foes (goal)
		foesStock=6;
		foesRemaining=3+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=1;
		
		//Init foes
		i=0;
		
		//Bouncing foe left
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->circularX=8;
		foe->circularXorigin=32;
		foe->circularXradius=2;
		foe->circularY=8;
		foe->circularYorigin=110;
		foe->circularYradius=2;
		foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
		foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
		foe->speedX=4;
		foe->speedY=4;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		
		//Next foe
		++i;
	
		//Bouncing foe right
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->circularX=158;
		foe->circularXorigin=192;
		foe->circularXradius=2;
		foe->circularY=158;
		foe->circularYorigin=110;
		foe->circularYradius=2;
		foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
		foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
		foe->speedX=-4;
		foe->speedY=-4;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
	
		//Next foe
		++i;
	
		//Bouncing foe right
		foe=&foes[i];
		//Set its vars
		foe->active=1;
		foe->circularX=88;
		foe->circularXorigin=112;
		foe->circularXradius=2;
		foe->circularY=88;
		foe->circularYorigin=20;
		foe->circularYradius=2;
		foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
		foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
		foe->speedX=4;
		foe->speedY=4;
		foe->consoleX=foe->x; 
		foe->consoleY=foe->y+32; 
		//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
		oamSetXY((30+i)*4, foe->x, foe->y);
		//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
		oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
		//Set its life and progress
		foe->life=241;
		foe->progress=0;
		//Update TV animation to first "unplugged countdown"
		foe->anim=11;
		oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
	
	
		//Init player in a console slot
		player.sticky=2;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	//Wheel of Death
	//===== LEVEL 20 ======
	else if( level == 20 ){
	
		//Number of foes (goal)
		foesStock=9;
		foesRemaining=6+foesStock;
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=2;
		
		//Init foes
		for( i = 0 ; i < 6 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			foe->active=1;
			foe->circularX=8+(40*i);
			foe->circularXorigin=112;
			foe->circularXradius=0;
			foe->circularY=8+(40*i);
			foe->circularYorigin=78;
			foe->circularYradius=0;
			foe->x=foe->circularXorigin+(LUTcircleX[foe->circularX] >> foe->circularXradius);
			foe->y=foe->circularYorigin+(LUTcircleY[foe->circularY] >> foe->circularYradius);
			foe->speedX=1;
			foe->speedY=1;
			foe->consoleX=foe->x; 
			foe->consoleY=foe->y+32; 
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown"
			foe->anim=11;
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player in a console slot
		player.sticky=0;
		player.x=foes[player.sticky].x+4;
		player.y=foes[player.sticky].y+33;
		player.anim=0;
		//Update animation of the TV we are in
		foes[player.sticky].anim=13;
		oamSetGfxOffset((30+player.sticky)*4, foeAnim[foes[player.sticky].anim]);
	}
	
	
	//Small survival mode and actual survival mode
	//===== LEVEL 18 ======
	//===== LEVEL 200 (SURVIVAL MODE) ======
	else if( level == 200 || level == 18){
	
		//Small survival mode ? (level with set goal but the survival mode mechanics)
		if( level == 18 ){
			//Number of foes (goal)
			foesStock=19;
			foesRemaining=1+foesStock;
		}
		//Actual survival mode
		else {
			//Number of foes (goal)
			foesStock=249;
			foesRemaining=1+foesStock;
		}
		
		//Set speeds: Increase (game progress) and decrease (tv life) - the higher the number, the slower the increase (max is 1, for every frame, else it's every X frames)
		increase=1;
		decrease=3;
		
		//Init foes
		for( i = 0 ; i < 10 ; ++i ){
			//Get current foe
			foe=&foes[i];
			//Set its vars
			//Prepare all the foes, but hides them all but one so they'll appear progressively
			if( i == 4 ){
				foe->active=1;
			} else {
				foe->active=0;
				//Make the foe disappear (tv and console)
				oamSetVisible((30+i)*4, OBJ_HIDE);
				oamSetVisible((40+i)*4, OBJ_HIDE);
			}
			if ( i <= 2 ){ 
				foe->x=40+(i*72);
				foe->y=8;
			} else if( i > 2 && i < 7 ){
				foe->x=4+((i-3)*72);
				foe->y=83;
			} else {
				foe->x=40+((i-7)*72);
				foe->y=158;
			}
			foe->consoleX=foe->x; 
			//Hides all the consoles offscreen, but one, so they'll appear "incoming" when the TV enters the game!
			if( i == 4 ){
				foe->consoleY=foe->y+32; 
			} else {
				foe->consoleY=224; 
			}
			//Reset it's TV sprites too (sprites #40-49 (*4 for the actual id in OAM))
			oamSetXY((30+i)*4, foe->x, foe->y);
			//Reset it's Console sprites too (sprites #30-39 (*4 for the actual id in OAM))
			oamSetXY((40+i)*4, foe->consoleX, foe->consoleY);
			//Set its life and progress
			foe->life=241;
			foe->progress=0;
			//Update TV animation to first "unplugged countdown" for the first TV, but to "disconnect" for all the other ones
			if( i == 4 ){
				foe->anim=11;
			} else {
				foe->anim=0;
			}
			oamSetGfxOffset((30+i)*4, foeAnim[foe->anim]);
		}
		
		//Init player outside a console slot
		player.sticky=255;
		player.x=foes[4].x+4;
		player.y=foes[4].y-30;
		player.anim=1;
	}
}


//UPDATE LEVEL FUNCTION
//This function manages the difficulty increase for the levels that use it (based on current player score)
//This function is called from gameplay loop each time the player completes a console progress (i.e. each time player score a point)
void updateLevel(){
	
	// !WARNING!
	//Don't use the "foe" pointer or the "i" variables here (globals!), 
	//Because they are used during the main foe update loop and this function is always called this foe update loop!
	
	//Two Floating TVs
	//===== LEVEL 4 ======
	if( level == 4 ){
	
		//Increase the foe speedX and Y at certain times
		if( score == 3 || score == 6 ){
			
			//For each foe
			for( j = 0 ; j < 2 ; ++j ){
				
				//SpeedX
				if( foes[j].speedX < 0 ){
					--foes[j].speedX;
				} else if( foes[j].speedX > 0 ){
					++foes[j].speedX;
				} //Don't modify if the speed is 0!
				
				//SpeedY
				if( foes[j].speedY < 0 ){
					--foes[j].speedY;
				} else if( foes[j].speedY > 0 ){
					++foes[j].speedY;
				} //Don't modify if the speed is 0!
			}
		}
	}
	
	//Easy Wheel
	//===== LEVEL 6 ======
	else if( level == 6 ){
	
		//Change speed some times
		//Speed up
		if( score == 6 ){
			//Modify the speed values of all the foes in the level
			for( j = 0 ; j < 5 ; ++j ){
				++foes[j].speedX;
				++foes[j].speedY;
			}
		}
	}
	
	//Single TV jump
	//===== LEVEL 12 ======
	else if( level == 12 ){
	
		//Increase the foe speedX each time the player scores!
		if( foes[0].speedX < 0 ){
			--foes[0].speedX;
		} else {
			++foes[0].speedX;
		}
	}
	
	//Wheel of Death
	//===== LEVEL 20 ======
	else if( level == 20 ){
	
		//Change speed every time
		//First speed up
		if( score == 2 ){
			//Modify the speed values of all the foes in the level
			for( j = 0 ; j < 6 ; ++j ){
				++foes[j].speedX;
				++foes[j].speedY;
			}
		}
		//Then stop (after a slow down triggered by the next section)
		else if( score == 5 ){
			//Modify the speed values of all the foes in the level
			for( j = 0 ; j < 6 ; ++j ){
				foes[j].speedX=0;
				foes[j].speedY=0;
			}
		}
		//Then reverse, and faster reverse
		else if( score == 4 || score == 6 || score == 8 ){
			//Modify the speed values of all the foes in the level
			for( j = 0 ; j < 6 ; ++j ){
				--foes[j].speedX;
				--foes[j].speedY;
			}
		}
		//Then chaos (speed X and Y are no longer aligned :))
		else if( score == 9 ){
			//Modify the speed values of all the foes in the level
			for( j = 0 ; j < 6 ; ++j ){
				foes[j].speedX=-1;
				foes[j].speedY=3;
			}
			//Slow down the decrease value as the level just turned from difficult to very difficult!
			decrease=3;
		}
	}
	
	//Small survival mode and actual survival mode
	//===== LEVEL 18 ======
	//===== LEVEL 200 (SURVIVAL) ======
	else if( level == 200 || level == 18 ){
		
		//Everytime we score, we modify the active foes
		//Special case for the first point scored!
		if( score == 1 ){
			
			//Always pick a specific foe
			j=5;
			
			//Activate the foe, but in it's "new console incoming" sequence (so it makes for a better appearing transition anim)
			foes[j].active=21;
			//The other values (console Y, TV anim) have been set accordingly during the buildLevel phase
			
			//Make the foe appear (tv and console)
			oamSetVisible((30+j)*4, OBJ_SHOW);
			oamSetVisible((40+j)*4, OBJ_SHOW);
		}
		//Else, normal situation for all other points scored!
		else {
			
			//Pick a foe at random
			j=(rand() % 10);
			
			//If the foe isn't active yet
			if( foes[j].active == 0 ){
				
				//Activate the foe, but in it's "new console incoming" sequence (so it makes for a better appearing transition anim)
				foes[j].active=21;
				//The other values (console Y, TV anim) have been set accordingly during the buildLevel phase
				
				//Make the foe appear (tv and console)
				oamSetVisible((30+j)*4, OBJ_SHOW);				
				oamSetVisible((40+j)*4, OBJ_SHOW);
			}
			//Else, the foe is active, so we'll mess with it's speed variables
			else {
				//Coin toss: modify X variable?
				if( (rand() % 2) == 0 ){
					//Use greater amplitude with larger scores
					if( score > 20 ){
						foes[j].speedX=2-(rand() % 5);
					} else {
						foes[j].speedX=1-(rand() % 3);
					}
				}
				//Else modify Y variable?
				else {
					//Use greater amplitude with larger scores
					if( score > 20 ){
						foes[j].speedY=2-(rand() % 5);
					} else {
						foes[j].speedY=1-(rand() % 3);
					}
				}
			}
		}	
	}
}
