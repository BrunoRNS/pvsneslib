/*
			The Last Super
			
	A small SNES game to celebrate the SNES 30th birthday.
	This game is a sequel / expanded version of a game I originally created in a Jam:
	Keeping SNES Alive: https://drludos.itch.io/keeping-snes-alive
	
						by Dr. Ludos (2020)
	
	Get all my other games: 
			http://drludos.itch.io/
	Support my work and get access to betas and prototypes:
			http://www.patreon.com/drludos

	Gameplay music: xracecar - 7049 Bytes of Memories
	Used under a Creative Commons BY-NC-SA license:
	http://battleofthebits.org/arena/Entry/7049+Bytes+of+Memories/25393/
	
	Title screen music: xracecar - ayyy you know the man
	Used under a Creative Commons BY-NC-SA license:
	http://battleofthebits.org/arena/Entry/ayyy+you+know+the+man.xm/23747/
	
	---------------
	
	This file contains the code related to menu, title screens, etc.
	
	Usually, I would code everything in one file (dirty coding FTW!)
	However, the C compiler I use (tcc816) has an hard limit on the number of if/then/else/functions it can generate (i.e. the number of labels where it can jumps to)
	This limit is quite low, around 1000 labels/identifier per C file
	So you have to break your game code in several files for it to be able to get compiled by tcc816.

*/

//Include SNESSDK and PVSNESlib
#include <snes.h>

//====================================
//=========== VARIABLES ===============
//====================================

//ASSETS

//Music and sound effects (soundbanks are automatically generated by PVSNESLIB)
#include "soundbank.h"
/*
extern char __SOUNDBANK__0;
extern char __SOUNDBANK__1;
extern char __SOUNDBANK__2;
*/

//Sprites and palettes memory addresses on ROM (defined in data.asm)
extern char sprites16GFX, sprites16GFX_end;
extern char sprites32GFX, sprites32GFX_end;
extern char spritesPAL, spritesPAL_end;

//Tiles, maps and palettes memory addresses on ROM (defined in data.asm)
//Background: gameplay
extern char bg_gameplayGFX, bg_gameplayGFX_end;
extern char bg_gameplayPAL, bg_gameplayPAL_end;
extern char bg_gameplayMAP, bg_gameplayMAP_end;

//Background : text messages (game over, well done)
extern char bg_msgGFX, bg_msgGFX_end;
extern char bg_msgPAL, bg_msgPAL_end;
extern char bg_msgMAP, bg_msgMAP_end;

//Title screen
extern char bg_titleGFX, bg_titleGFX_end;
extern char bg_titlePAL, bg_titlePAL_end;
extern char bg_titleMAP, bg_titleMAP_end;


//load the font to use with PVSNESLib text system
extern char snesfont;

//Variable to detect if we're running PAL (== 1) or NTSC (==0) mode
extern unsigned char snes_50hz;


//GAMEPLAY VARIABLES

//Define the Screen dimentions
enum {SCREEN_TOP = 2, SCREEN_BOTTOM = 223, SCREEN_LEFT = 3, SCREEN_RIGHT = 252};

//Gameplay and backend variables
extern u8 STATE; //Current program state : 0: title & howto / 1: gameplay / 2: game over / 3: level completed

//Iterators
extern u8 i, j; //8 bit iterators
extern u16 m; //16 bit iterators

//Ticks counter (frame counter + modulo computed each frame to trigger 4 "every X frame" counter, so we can move at speed slower than 60 pixel / seconds - 60fps game baby!)
//Frame counter (resetted every 240 frames (4 seconds), so it can be used for countdown too)
extern u8 ticks;
//Fast speed : triggered every 2 frames
extern u8 ticks_fast;
//Mid speed : triggered every 4 frames
extern u8 ticks_mid;
//Slow speed : triggered every 8 frames
extern u8 ticks_slow;
//Slower speed : triggered every 16 frames
extern u8 ticks_slower;

//This one is used for animation (it's a countdown reused by the game over / title state)
extern u16 ticks_anim;

//This one is to track the current menu position
extern u8 menu_step;

//Buffer for palette color change commands (as they need to take place during Vblank!)
//it uses two 16 bits values (one for palette adress, one for the new color data)
extern u16 colorChangeADDR; 
extern u16 colorChangeDATA;

//State of the Player 1 gamepad
extern u16 pad0;

//Pressed buttons vars
extern u8 pressedJUMP; //for P1

//Pausing / unpausing vars
extern u8 pressedSTART; // for P1 
extern u8 pressedSELECT; // for P1 
extern u8 isPaused; //If == 1, then the game is paused
extern u8 musicPaused; //If == 1, then the music is paused

//Screenshake vars
extern u8 screenshake; //used to do the screenshake (if > 0, we shake the screen!)

//Score
extern u16 score; //will count the number of SNES we managed to play with
extern u16 highscore; //will store the current highscore (survival mode only)
extern u8 refreshScore; //if = 1 we will udpate score display (used to avoid doing it every frame, as the printf function are VERY consuming on the CPU time)

//Gameplay
extern u8 level; //Current level number
extern u8 foesRemaining; //number of foes remaining to complete the level (current active foes + the ones in stock)
extern u8 foesStock; //number of foes remaining in stock (to be spawned when a console is completed)
extern u8 increase; //Speed at which the "game progress" (0-100) increases: 1: every frame / 2: every 2 frames / 3: every 3 frames, etc.
extern u8 decrease; //Speed at which the "tv life" (241-0) decreases: 1: every frame / 2: every 2 frames / 3: every 3 frames, etc.

//Ticks to compute whether we need to increase/decrease value once for all foes
extern u8 ticks_increase;
extern u8 ticks_decrease;

//Animations
extern const u16 playerAnim[];
extern const u16 foeAnim[];
extern const u16 consoleAnim[];
extern const u16 boomAnim[];

//Functions declarations
extern void init();
extern void startGame();

/*
//Non-extern functions
void updateTitle();
void initHowto();
*/

//TITLE SCREEN VARIABLES (non-extern, only used in this file)
u8 posY;
u16 scrollY;
s8 speedY;
u8 fadeTV;
u8 animTV;

//=================================================
//=========== HOW TO PLAY SCREEN ==================
//=================================================
//This function inits the "how to play" screen (it'll be "updated" every frame in the menu code itself, this function only initializes the screen)
void initHowto(){
	
	//Clear the BG3 to erase all text display
	//Fill the text map variable with 0x00 (empty) tile
	for (m=0; m < 0x800; ++m){
		pvsneslibfont_map[m] = 0x00;
	}
	//And send the map to VRAM into the location used by PVSNESlib's text engine (read console.h for more info)
	dmaCopyVram(pvsneslibfont_map, 0x800, 0x800);
	
	//Hide the BG to have a fully black screen (so no BG for this screen)
	bgSetDisable(1);
	
	//Display the instructions text on it
	consoleDrawText(11,1,"HOW TO PLAY");
	consoleDrawText(3,4,"MOVE THE CARTRIDGE AROUND");
	consoleDrawText(3,5,"SO EVERY SNES CAN USE IT!");
	
	//Move the cart and console from title screen (foe index 0) to the first instruction paragraph
	oamSetXY(80,  28, 97);
	oamSetXY(120,  24, 64);
	oamSetXY(160,  24, 96);
	
	//First instruction paragraph
	consoleDrawText(10,10,"STAY INSIDE A SNES");
	consoleDrawText(10,11,"TO FINISH THE GAME");
	consoleDrawText(10,12,"(Game progress is");
	consoleDrawText(10,13,"saved for each snes)");
	
	//Display the exploding TV using other sprites (foe index 1) for the second paragraph

	//Reset it's TV sprites too (sprites #30-39 (*4 for the actual id in OAM))
	oamSet( 124, 200, 134, 2, 0, 0,  foeAnim[0], 1);
	oamSetEx( 124, OBJ_LARGE, OBJ_SHOW);
	oamSetVisible(124, OBJ_SHOW);
	
	//Reset it's Console sprites too (sprites #40-49 (*4 for the actual id in OAM))
	oamSet( 164, 200, 166, 2, 0, 0,  consoleAnim[0], 3);
	oamSetEx( 164, OBJ_LARGE, OBJ_SHOW);
	oamSetVisible( 164, OBJ_SHOW);
	
	//Second instruction paragraph
	consoleDrawText(3,19,"DON'T LET A CONSOLE");
	consoleDrawText(3,20,"WITHOUT CARTRIDGE");
	consoleDrawText(3,21,"FOR TOO LONG!");
	
	//Animation variables
	fadeTV=0;
	animTV=13;
	
	//Reset the TV gameplay BG color to its starting value
	//Write the adress of the color to change to the dedicated register (palette 9 - color 16)
	REG_CGADD = 0x9F; 
	//Then write the data of the color to change to the dedicated register (this one is a 8 bit register expecting a 16 bit value in two sequentiel writes)
	*CGRAM_PALETTE = RGB5(fadeTV, fadeTV, fadeTV) & 0xFF; 
	*CGRAM_PALETTE = RGB5(fadeTV, fadeTV, fadeTV) >> 8;

	//Fade in to display screen!
	setFadeEffect(FADE_IN);
}
	

//==========================================================
//=========== TITLE SCREEN UPDATE FUNCTION ==================
//==========================================================
//This function handle the menu (so it doesn't add length to the main loop, as it's not time-critical code anyway)
void updateTitle(){
	
	//TICKS (specific to this screen)
	
	//Increase the frame counter
	++ticks;
	
	//Reset it to zero every 32 ticks, as it's only used for blinking animation :)
	if (ticks == 33){
		ticks=1;
	}
	
	
	//INTRO ANIMATION
	//If the intro animation isn't finished yet
	if( ticks_anim > 0 ){
	
		//Game Intro anim screen
		if( ticks_anim == 560 ){
			
			//Init the cartridge Y position variable
			posY=224;
			//And makes it jump!
			speedY=-7;
			
			//Init the scroll position too
			scrollY=0;
			
			//And the TV anim and screen color fade too
			animTV=0;
			fadeTV=0;
			
			//Set Cartridge Sprite parameters - sprite #20 (*4 for the actual id in OAM)
			//Params: id,  xspr, yspr, priority, hflip, vflip, gfxoffset, paletteoffset
			oamSet(80, 116, posY, 2, 0, 0, playerAnim[1], 2);
			oamSetEx(80, OBJ_LARGE, OBJ_SHOW);
			oamSetVisible(80, OBJ_SHOW);
					
			//Set TV sprite too (sprites #30 (*4 for the actual id in OAM))
			oamSet( 120, 112, 224, 2, 0, 0,  foeAnim[0], 1);
			oamSetEx( 120, OBJ_LARGE, OBJ_SHOW);
			oamSetVisible(120, OBJ_SHOW);
			
			//Set Console sprite too (sprites #40 (*4 for the actual id in OAM))
			oamSet( 160, 112, 224, 2, 0, 0,  consoleAnim[0], 3);
			oamSetEx( 160, OBJ_LARGE, OBJ_SHOW);
			oamSetVisible( 160, OBJ_SHOW);
			
			//Load the music
			spcLoad(MOD_MUSIC_TITLE);
			
			//Play Music from the beginning 
			spcSetModuleVolume(0);
			spcPlay(0);
			//Will trigger a progressive fade in volume effects after the music starts (SNESMod is a wonderful audio driver! :))
			spcFadeModuleVolume(1, 100);
		}
		//Fade the intro text (1/3)
		else if( ticks_anim < 560 && ticks_anim >= 530 ){
		
			//Fade the intro text color to white to make a cool fading effect (1/3)
			//Write the adress of the color to change to the dedicated buffer (palette1 - color 5)
			colorChangeADDR= 0x15; 
			//Then write the data of the color to change to the dedicated buffer (see main loop for the color change buffer code)
			colorChangeDATA = RGB5(31-((ticks_anim-530)), 31-((ticks_anim-530)), 31-((ticks_anim-530)));
		}
		//Fade the intro text (2/3)
		else if( ticks_anim < 515 && ticks_anim >= 485 ){
		
			//Fade the intro text color to white to make a cool fading effect (2/3)
			//Write the adress of the color to change to the dedicated buffer (palette1 - color 6)
			colorChangeADDR= 0x16; 
			//Then write the data of the color to change to the dedicated buffer (see main loop for the color change buffer code)
			colorChangeDATA = RGB5(31-((ticks_anim-485)), 31-((ticks_anim-485)), 31-((ticks_anim-485)));
		}
		//Fade the intro text (1/3)
		else if( ticks_anim < 440 && ticks_anim >= 380 ){
		
			//Fade the intro text color to white to make a cool fading effect (3/3)
			//Write the adress of the color to change to the dedicated buffer (palette1 - color 7)
			colorChangeADDR= 0x17; 
			//Then write the data of the color to change to the dedicated buffer (see main loop for the color change buffer code)
			colorChangeDATA = RGB5(31-((ticks_anim-380)/2), 31-((ticks_anim-380)/2), 31-((ticks_anim-380)/2));
		}
		//Make the cartridge jump, and fall down!
		else if( ticks_anim < 280 && ticks_anim >= 100 ){
			
			//Jumping start!
			if( ticks_anim == 279 ){
				//Play Sound
				spcEffect(8, MOD_AUDIO_JUMP, 248);
			}
			
			//Oh, gravity (capped a 8 pixel / frame)
			if( !(ticks % 6) && speedY < 8 ){ //We have to use a modulo here, as the bitmasks don't allow us to have a value that "feels good" when we play :)
				//Increase player Y speed so he goes down!
				++speedY;
			}
			
			//Do we have to make the cart sprite move onscreen?
			if( posY < 189 || speedY <= 0 ){
			
				//Update cartridge position
				posY += speedY;
			
				//Update the cart sprite position
				oamSetXY(80, 116, posY);
			}
			//Else, move the scrolling!
			else if( scrollY < 256 ){
				
				//Set the cart at its final position
				posY=189;
				oamSetXY(80,  116, posY);
				
				//Update the scrolling position
				scrollY += speedY;
				
				//And scroll the BG layer onscreen
				bgSetScroll(1, 0, scrollY);
				
				//Scroll the TV too when needed
				if( scrollY >= 188 ){ //=> 256 - (224 - final Y pos (here: 156) = 68) = 188
					oamSetXY(120,  112, 224+188-scrollY);
				}
				
				//Scroll the console too when needed
				if( scrollY >= 220 ){ //=> 256 - (224 - final Y pos (here: 188) = 36) = 220
					oamSetXY(160,  112, 224+220-scrollY);
				}
			}
			//Else, fade in the TV screen
			else if( fadeTV < 27 ){
				
				//Init first step of the fade / anim TV sequence
				if( animTV < 13 ){
				
					//Change the cart animation
					oamSetGfxOffset(80, playerAnim[0]);
					
					//Force the TV and console to their final positions
					oamSetXY(120,  112, 156);
					oamSetXY(160,  112, 188);
					
					//And display the start of the TV animation
					animTV=13;
					
					//Play Sound
					spcEffect(8, MOD_AUDIO_LIFEUP, 248);
				}
				
				//Increase the TV fade
				++fadeTV;
				
				//And apply it
				//Fade the tv screen color to white to make a cool fading effect
				//Write the adress of the color to change to the dedicated buffer (palette9 - color 16)
				colorChangeADDR= 0x9F; 
				//Then write the data of the color to change to the dedicated buffer (see main loop for the color change buffer code)
				colorChangeDATA = RGB5(fadeTV, fadeTV, fadeTV);
			}
		}
		//Make the title screen fade in!
		else if( ticks_anim <= 92 && ticks_anim >= 30 ){
			
			//Fade the title screen logo color to red to make a cool fading effect
			//Write the adress of the color to change to the dedicated buffer (palette1 - color 2)
			colorChangeADDR= 0x12; 
			//Then write the data of the color to change to the dedicated buffer (see main loop for the color change buffer code)
			colorChangeDATA = RGB5(31-((ticks_anim-30)/2), 0, 0);
		}
		//Display credits
		else if( ticks_anim == 1 ){
			
			//Display the various menu options as text entries
			consoleDrawText(23,25," Game by");
			consoleDrawText(23,26,"DR.LUDOS");
			consoleDrawText(1,25,"music by");
			consoleDrawText(1,26,"XRACECAR");
		}
		
		
		//Decrease countdown
		--ticks_anim;
	}
	//Else, the animation is finished, so we can actually interact with the menu screen
	else {
		
		//MENU STEP 1
		//press button to open menu
		if( menu_step == 0 ){
		
			//Make the "press button" message blink
			if( ticks < 16 ){
				consoleDrawText(10,13,"PRESS BUTTON");
			} else {
				consoleDrawText(10,13,"            ");
			}
		
			//If button is pressed
			if( pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A || pad0 & KEY_START ){
				
				//Only once per button press
				if( pressedJUMP == 0 ){
					
					//go to the next "menu step"
					menu_step=1;
					
					//Clear the "press button" message
					consoleDrawText(10,13,"            ");
					
					//Display the menu elements
					consoleDrawText(11,12,"> ARCADE   ");
					consoleDrawText(11,14,"  SURVIVAL ");
					
					//Do it only once per button press
					pressedJUMP=10; //Not 1 because of the "progressive jump" feature, that can increase this variable up to 7
				}
			}
			else {
				//Mark down the button as released
				pressedJUMP=0;
			}
			
		}
		
		//MENU STEP 2
		//Menu step 2 (main menu) : menu_step > 0 and <= 10 is used to keep track of current menu option selected!
		else if( menu_step <= 10 ){
		
			//Move in the menu using the direction keys
			//When any button, start, or up, down, left or right is pressed
			if( pad0 & KEY_UP || pad0 & KEY_DOWN || pad0 & KEY_LEFT || pad0 & KEY_RIGHT || pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A || pad0 & KEY_START){
				
				//LIMITED ACTIONS
				//Only once per button press
				if( pressedJUMP == 0 ){
				
					//Move in the menu up and down
					//Up
					if( pad0 & KEY_UP ){
						//Clear previous cursor display
						consoleDrawText(11, 10+(menu_step << 1), " ");
						
						//Decrease menu option (and wrap)
						if( menu_step > 1 ){ --menu_step; }
						else { menu_step=2; }
						
						//Update menu option cursor display
						consoleDrawText(11, 10+(menu_step << 1), ">");
					}
					//Down
					else if( pad0 & KEY_DOWN ){
						//Clear previous cursor display
						consoleDrawText(11, 10+(menu_step << 1), " ");
						
						//Increase menu option (and wrap)
						if(  menu_step  < 2 ){ ++ menu_step; }
						else {  menu_step =1; }
						
						//Update menu option cursor display
						consoleDrawText(11, 10+(menu_step << 1), ">");
					}
					
					//If an action button is pressed
					if( pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A || pad0 & KEY_START ){
						
						//Menu Item 1: ARCADE (open level select)
						if( menu_step == 1 ){
							
							//Erase the current menu
							consoleDrawText(11,12,"           ");
							consoleDrawText(11,14,"           ");
							
							//go to the next "menu step"
							menu_step=11;
							
							//Set the current level selection default value
							level=1;
							
							//Display the menu elements
							consoleDrawText(11,12,"> START    ");
							consoleDrawText(11,14,"  LEVEL: 01/20");
							consoleDrawText(11,16,"  BACK     ");
						}
						
						//Menu Item 2: SURVIVAL (launch game)
						else if( menu_step == 2 ){
							
							//Stop music
							spcSetModuleVolume(0);
							
							//Fade out
							setFadeEffect(FADE_OUT);
							
							//Set forced blanking for unlimited VRAM access
							setBrightness(0);
				
							//Set the level to "Survival Mode"
							level=200;
							
							//Load the ingame background Tileset and its palette (on slot 1 and after, as palette slot 0 is for text)
							bgInitTileSet(1, &bg_gameplayGFX, &bg_gameplayPAL, 1, (&bg_gameplayGFX_end - &bg_gameplayGFX), 16 << 1, BG_16COLORS, 0x4000);
							bgInitMapSet(1, &bg_gameplayMAP, (&bg_gameplayMAP_end - &bg_gameplayMAP), SC_32x32, 0x3000);
							bgSetEnable(1);
							//Load the text messages (game over / well done) on BG0 (over BG1, and over sprites too thanks to the high priority)
							bgInitTileSet(0, &bg_msgGFX, &bg_msgPAL, 2, (&bg_msgGFX_end - &bg_msgGFX), 16 << 1, BG_16COLORS, 0x2000);
							bgInitMapSet(0, &bg_msgMAP, (&bg_msgMAP_end - &bg_msgMAP), SC_32x64, 0x1000);
							bgSetDisable(0);
							
							//Start the game now! (will do a fadein after the game init)
							startGame();
						}

					}
					
					//Do it only once per button press
					pressedJUMP=10;  //Not 1 because of the "progressive jump" feature, that can increase this variable up to 7
				}
			}
			else {
				//Mark down the button as released
				pressedJUMP=0;
			}
		}
		
		//MENU STEP 3
		//Menu step 3 (level select) : menu_step > 10 and <= 20 is used to keep track of current menu option selected!
		else if( menu_step <= 20 ){
			
			//Move in the menu using the direction keys
			//When any button, start, or up, down, left or right is pressed
			if( pad0 & KEY_UP || pad0 & KEY_DOWN || pad0 & KEY_LEFT || pad0 & KEY_RIGHT || pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A || pad0 & KEY_START ){
				
				//LIMITED ACTIONS
				//Only once per button press
				if( pressedJUMP == 0 ){
				
					//Move in the menu up and down
					//Up
					if( pad0 & KEY_UP ){
						//Clear previous cursor display
						consoleDrawText(11, 10+((menu_step-10) << 1), " ");
						
						//Decrease menu option (and wrap)
						if( menu_step > 11 ){ --menu_step; }
						else { menu_step=13; }
						
						//Update menu option cursor display
						consoleDrawText(11, 10+((menu_step-10) << 1), ">");
					}
					//Down
					else if( pad0 & KEY_DOWN ){
						//Clear previous cursor display
						consoleDrawText(11, 10+((menu_step-10) << 1), " ");
						
						//Increase menu option (and wrap)
						if(  menu_step  < 13 ){ ++menu_step; }
						else {  menu_step=11; }
						
						//Update menu option cursor display
						consoleDrawText(11, 10+((menu_step-10) << 1), ">");
					}
					
					//Change level with left and right (or B/X and A/Y)
					//Left key (or button Y/A if we are on the level select item)
					if( pad0 & KEY_LEFT || ((pad0 & KEY_Y) && menu_step == 12) || ((pad0 & KEY_A) && menu_step == 12)  ){
						
						//Decrease level (and wrap)
						if( level > 1 ){ --level; }
						else { level=20; }
						
						//Update the current level number display
						if( level < 10 ){
							consoleDrawText(20,14,"0%d", (u16)level);
						} else {
							consoleDrawText(20,14,"%d", (u16)level);
						}
					}
					//Right key (or button B/X if we are on the level select item)
					else if( pad0 & KEY_RIGHT || ((pad0 & KEY_B) && menu_step == 12) || ((pad0 & KEY_X) && menu_step == 12)  ){
						
						//Increase level (and wrap)
						if( level < 20 ){ ++level; }
						else { level=1; }
						
						//Update the current level number display
						if( level < 10 ){
							consoleDrawText(20,14,"0%d", (u16)level);
						} else {
							consoleDrawText(20,14,"%d", (u16)level);
						}
					}
					
					//If an action button is pressed
					if( pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A || pad0 & KEY_START ){
						
						//Menu Item 1: START (launch game in the currently selected level)
						if( menu_step == 11 ){
							
							//Stop music
							spcSetModuleVolume(0);
							
							//Fade out
							setFadeEffect(FADE_OUT);
							
							//Set forced blanking for unlimited VRAM access
							setBrightness(0);
							
							//If we are on level 1, display the "how to play" screen before launching the game
							if( level == 1 ){
								
								//Go to the "how to play screen" step
								menu_step=100;
								
								//And displays it
								initHowto();
							}
							//Else, launch the game directly
							else {
								//Load the ingame background Tileset and its palette (on slot 1 and after, as palette slot 0 is for text)
								bgInitTileSet(1, &bg_gameplayGFX, &bg_gameplayPAL, 1, (&bg_gameplayGFX_end - &bg_gameplayGFX), 16 << 1, BG_16COLORS, 0x4000);
								bgInitMapSet(1, &bg_gameplayMAP, (&bg_gameplayMAP_end - &bg_gameplayMAP), SC_32x32, 0x3000);
								bgSetEnable(1);
								//Load the text messages (game over / well done) on BG0 (over BG1, and over sprites too thanks to the high priority)
								bgInitTileSet(0, &bg_msgGFX, &bg_msgPAL, 2, (&bg_msgGFX_end - &bg_msgGFX), 16 << 1, BG_16COLORS, 0x2000);
								bgInitMapSet(0, &bg_msgMAP, (&bg_msgMAP_end - &bg_msgMAP), SC_32x64, 0x1000);
								bgSetDisable(0);
								
								//Start the game now! (will do a fadein after the game init)
								startGame();
							}
						}
						
						//Menu Item 3: BACK (go back to main menu)
						else if( menu_step == 13 ){
							
							//Erase the current menu
							consoleDrawText(11,12,"           ");
							consoleDrawText(11,14,"              ");
							consoleDrawText(11,16,"           ");
							
							//Go to the previous menu step
							menu_step=1;
							
							//Display the new menu elements
							consoleDrawText(11,12,"> ARCADE   ");
							consoleDrawText(11,14,"  SURVIVAL ");
						}
					}
					
					//Do it only once per button press
					pressedJUMP=10;  //Not 1 because of the "progressive jump" feature, that can increase this variable up to 7
				}
			}
			else {
				//Mark down the button as released
				pressedJUMP=0;
			}
			
		}
		
		//MENU STEP 4
		//Menu step 4 (how to play) : menu_step = 100 means that we are on this "instruction" screen
		else if( menu_step == 100 ){
			
			//Launch the game when any button is pressed
			//When any button or start is pressed
			if( pad0 & KEY_B || pad0 & KEY_X || pad0 & KEY_Y || pad0 & KEY_A || pad0 & KEY_START ){
				
				//LIMITED ACTIONS
				//Only once per button press
				if( pressedJUMP == 0 ){

					//Fade out
					setFadeEffect(FADE_OUT);
					
					//Set forced blanking for unlimited VRAM access
					setBrightness(0);
					
					//Load the ingame background Tileset and its palette (on slot 1 and after, as palette slot 0 is for text)
					bgInitTileSet(1, &bg_gameplayGFX, &bg_gameplayPAL, 1, (&bg_gameplayGFX_end - &bg_gameplayGFX), 16 << 1, BG_16COLORS, 0x4000);
					bgInitMapSet(1, &bg_gameplayMAP, (&bg_gameplayMAP_end - &bg_gameplayMAP), SC_32x32, 0x3000);
					bgSetEnable(1);
					//Load the text messages (game over / well done) on BG0 (over BG1, and over sprites too thanks to the high priority)
					bgInitTileSet(0, &bg_msgGFX, &bg_msgPAL, 2, (&bg_msgGFX_end - &bg_msgGFX), 16 << 1, BG_16COLORS, 0x2000);
					bgInitMapSet(0, &bg_msgMAP, (&bg_msgMAP_end - &bg_msgMAP), SC_32x64, 0x1000);
					bgSetDisable(0);
					
					//Start the game now! (will do a fadein after the game init)
					startGame();
				
					//Reset the menu step so the "how to screen" animation won't be updated after startGame (title screen anim is made AFTER this if/then menu sections)
					menu_step=11;
					
					//Do it only once per button press
					pressedJUMP=10;  //Not 1 because of the "progressive jump" feature, that can increase this variable up to 7
				}
			}
			else {
				//Mark down the button as released
				pressedJUMP=0;
			}
		}
	}
	
	
	//PERMANENT ANIMATION (for both intro anim and title screen menu)
	
	//If we are not on the "how to play" screen, normal title screen animation
	if( menu_step != 100 ){
	
		//Keep on animating the TV screen if the anim is > 0
		if( animTV > 0 ){
			
			//Make the TV screen loop between 3 still images from the game
			if( !(ticks & 7) ){
				
				//Increase current animation frame
				++animTV;
				
				//Make it loop if needed
				if( animTV > 15 ){
					animTV=13;
				}
				
				//Update the TV animation on screen
				oamSetGfxOffset(120, foeAnim[animTV]);
			}
		}
	}
	//Else, animation for the "how to play" screen only
	else {
		
		//Make the "press button" message blink at the bottom of the screen
		if( ticks < 16 ){
			consoleDrawText(10,26,"PRESS BUTTON");
		} else {
			consoleDrawText(10,26,"            ");
		}
		
		//Keep on animating the TV screen if the anim frame isn't the last one ("The End" screen, anim frame index 12)
		if( animTV >= 13 ){
			
			//Make the TV screen loop between 3 still images from the game
			if( !(ticks & 7) ){
				
				//Increase current animation frame
				++animTV;
				
				//Make it loop if needed
				if( animTV > 15 ){
					animTV=13;
				}
				
				//Update the TV animation on screen
				oamSetGfxOffset(120, foeAnim[animTV]);
			}
		}
		
		//If the fade / explosion animation isn't over
		if( fadeTV < 50 ){
		
			//FADE
			//if the fade isn't over
			if( fadeTV < 31 ){
				
				//Slowly fade the screen color from black to white (from 0 to 31)
				//Write the adress of the color to change to the dedicated buffer (palette9 - color 16)
				colorChangeADDR= 0x9F; 
				//Then write the data of the color to change to the dedicated buffer (see main loop for the color change buffer code)
				colorChangeDATA = RGB5(fadeTV, fadeTV, fadeTV);
			}
			//else display "the end" screen on TV
			else if( fadeTV == 31 ){
				
				//Display the ending screen
				animTV=12;
				
				//Update the TV animation on screen
				oamSetGfxOffset(120, foeAnim[animTV]);
			}
			
			//COUNTDOWN TO EXPLOSION
			//if the countdown isn't over
			if( fadeTV < 30 ){
				//Update the TV animation on screen to display countdown (use FadeTV as anim index, as the var keeps on increasing before looping)
				oamSetGfxOffset(124, foeAnim[(11-(fadeTV/3))]);
			}	
			//Blinking countdown before explosion		
			else if (fadeTV < 36){
				
				//Update the TV animation on screen
				if( (fadeTV & 1) == 0 ){
					oamSetGfxOffset(124, foeAnim[2]);
				} else {
					oamSetGfxOffset(124, foeAnim[1]);
				}
			}
			//Shutting down TV
			else if (fadeTV == 36) {
				//Update the TV animation on screen to "empty" TV screen
				oamSetGfxOffset(124, foeAnim[0]);
			}
			//And make the SNES explode
			else if (fadeTV <= 45) {
				//Replace the SNES sprite by the boom sprites anim! (with different palette too, so we have to use oamSet instead of simply oamSetGfxOffset)
				oamSet(164, 200, 166, 2, 0, 0,  boomAnim[(fadeTV-37)], 0);
			}
			//Else the SNES has exploded and will stay invisible for a while!
			else if (fadeTV == 46) {
				//Replace the SNES sprite by an empty sprite to make it disappear (i.e. the first frame of the boom anim)
				oamSetGfxOffset(164, boomAnim[0]);
			}
			
			//Increase the TV fade (slowly) - actually this variable is used as a "ticks_anim" counter for the whole "how to play" screen animation
			if( !(ticks & 7) ){
				++fadeTV;
			}
		}
		//Else, reset the anim back to beginning
		else {
			//Reset variables
			fadeTV=0;
			animTV=13;
			//reset the SNES anim and palette back to normal too
			oamSet( 164, 200, 166, 2, 0, 0,  consoleAnim[0], 3);
		}
	}
}
